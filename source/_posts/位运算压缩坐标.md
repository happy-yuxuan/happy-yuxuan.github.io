---
title: 位运算压缩坐标(x, y)的技巧以及背后原理
date: 2020-03-13 12:12:00
categories:
- [算法, 位运算]
tags:
- 编程
---

# 使用位运算压缩坐标(x, y)的技巧以及背后原理

* 把一个`int型`坐标(x, y)转换成一个`long long类型`的整数，方便存储位置状态。

### 思路
假如题目给了很多坐标，需要保存坐标的唯一标识，从而表示坐标的状态信息。

* 因为坐标是int型是32位的(64位机)，而long long类型是64位的。 所以可以让高的32保存x的坐标，低32位保存y的坐标。

* 在编码(encode)的使用，先把x坐标和y坐标转换成long long类型，并向左移32位(左移补0)。然后用把当前数按位或y坐标。得到低32位是y，高32位是x。
* 在解码(decode)的时候，获得y坐标直接把编码后的数point强制类型转换成int(强制类型转换直接取低32位)。取x坐标要先把point右移32位再强制类型转换获得x坐标。

*PS：假如坐标有负数，需要在encode的时候需要在强转后把y的前32位置成0，因为负数int强制类型转换成long long高32位会补1(正数补0，计算机保存的是数的补码，整数的补码跟本身一样，负数的补码要取反+1)增加` y &= 0x00000000ffffffff;` 把高32位置0， 这样按位或就能保存x的值了。*


举一个栗子：
`x = 60, y = -32760` 计算机**补码**保存如下：

`x = 0000 0000 0000 0000 0000 0000 0011 1100` 
`y = 1111 1111 1111 1111 1000 0000 0000 1000` 
强制类型转换成long long类型64位
`x = 00000000000000000000000000000000 0000 0000 0000 0000 0000 0000 0011 1100` 
`y = 11111111111111111111111111111111 1111 1111 1111 1111 1000 0000 0000 1000` 
按位与



x: `0000 0000 0000 0000 0000 0000 0011 1100` `0000 0000 0000 0000 0000 0000 0000 0000` (x右移32位)
y: `0000 0000 0000 0000 0000 0000 0000 0000` `1111 1111 1111 1111 1000 0000 0000 1000` (把y的高32位置成0)

p: `0000 0000 0000 0000 0000 0000 0011 1100` `1111 1111 1111 1111 1000 0000 0000 1000`

p为压缩后的坐标。

### 使用

由`encode`和`decode`方法

#### encode

```c++
long long encode(long long x, long long y) {
    y &= 0x00000000ffffffff;  // 若y > 0可以不写
    return x << 32 | y;
}
```

#### decode

```c++
pair<int, int> decode(long long point) {
    return {(int)(point >> 32), (int)point};
}
```

#### 例子
```c++
// 使用例子， 把坐标放到各个容器中，以queue为例
queue<long long> q;

int x = 299, y = -40;  // (x, y) == (299, -40)
q.push(encode(x, y);  // 把坐标状态压入队列

pair<int, int> point = decode(q.front());   // 取出状态还原坐标 
// point.first == 299,   point.second == -40
```