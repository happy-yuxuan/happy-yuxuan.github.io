---
title: 图的构建
date: 2019-5-12 22:08:14
categories:
- [算法, 图论]
tags:
- 编程
---



# 树 & 图

* 树是特殊的图， 无向图是特殊的有向图，所以只需要研究有向图的即可


## 邻接矩阵 
(稠密图使用， N^2 跟M是一个规模的时候才使用)
**优点：** 找任意两点是否连通块， 可以多存一维的信息，如g[i][j]可以代表权重  

### 构建

```c++
int g[N][N];    // LeetCode 这样给出 vector<vector<int>> edge

// g[a][b] 存储边a->b
void add(int a, int b) {
    g[a][b] = 1;
    // g[b][a] = 1;
}
```

* 处理自环和重边， 只需要保留最小的一条边就可以了

### Dijkstra朴素版本
朴素算法: 适合使用邻接矩阵，在边数特别多的时候才使用邻接矩阵的朴素版本
时间复杂度为 O( N^2 )  因为n比较小所以使用

思路：
1. 把出发点u设置成0 dist[u] = 0， 其余点都设置成为 正无穷
2. 迭代n次(n为节点个数) 将没有确定的点里出发点u最近的点找出来，设为t；
3. t加入确定的点中
4. 用t更新 跟t连接的点的距离(从出发点到该点， 还是t作为中介点)

从1点到n点的最小值。 Acwing 849
```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 510;
int g[N][N], n, m;
int dist[N], vis[N];

void add(int a, int b, int c) {
    g[a][b] = min(g[a][b], c);
}

int dijkstra(int u) {
    memset(dist, 0x3f, sizeof dist);    // 记得每次先初始化距离
    dist[u] = 0;
    for (int i = 0; i < n; i++) {    // 进行n次迭代，每次迭代加入一个点
        int t = -1;
        for (int j = 1; j <= n; j++) {
            if (!vis[j] && (t == -1 || dist[t] > dist[j])) {
                t = j;
            }
        }
        vis[t] = 1;
        for (int j = 1; j <= n; j++) {
            dist[j] = min(dist[j], dist[t] + g[t][j]);
        }
    }
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

int main() {
    memset(g, 0x3f, sizeof g);
    scanf("%d%d", &n, &m);
    for (int i = 0; i < m; i++) {
        int a, b, c; scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }
    int ans = dijkstra(1);
    printf("%d\n", ans);
    return 0;
}
```

## 邻接表 
(稀疏图使用 N跟M的规模差不多的时候) 使用较多

**优点：** 找一个顶点的所有边比较快， 省空间， 可以有重边

### 构建

使用一个单链表(静态)，把每个节点对应的边组成一条链。 h[k] 存储这个顶点k的边链的头结点

```c++
/**
 * 节点维度 N个顶点
 * h[i] 对应节点中边链中一个的地址
 * 
 * 边维度 M 最多有 N*(N-1)条边 每一个节点都跟另外N-1个顶点有边
 * e[] 地址对应的node元素是几号，即这个地址对应的元素编号
 * ne[] 下一条边的地址
 * inx 边的数量，一直指向最后添加进来的一条边的地址。 idx是对应元素的地址
 */
int h[N], e[M], ne[M], idx;

void add(int a, int b) {
    e[idx] = b; ne[idx] = h[a], h[a] = idx++;
}


// !!!!务必记得初始化
memset(h, -1, sizeof h);
idx = 0; // 全局变量自动为0

```

### 遍历一个顶点的所有边
遍历6号顶点的所有边
```c++
for (int i = h[6]; i != -1; i = ne[i]) {
    cout << e[i] << " ";    // e[i]为顶点编号
}
```

### dfs

* 一条路走到黑, 可以带返回值上来

```c++
// 返回以u为根节点的子树的大小 Acwing846题
int dfs(int u) {
    vis[u] = 1;
    int size = 1, king = 0;
    for (int i = h[u]; i != -1; i = ne[i]) {
        int child = e[i];
        if (!vis[child]) {
            int t = dfs(child);
            king = max(king, t);
            size += t;
        }
    }
    king = max(king, n - size);
    ans = min(ans, king);
    return size;
}
```

### bfs

把bfs 算法应用于无权图，或者所有边的权都相等的图，bfs搜索等同于Dijkstra算法。

```c++
int h[N], e[N], ne[N], idx;
bool vis[N];
int dist[N];

// 计算u节点到n节点的最短距离(无权图距离都是1)
int bfs(int u) {
    memset(dist, -1, sizeof dist);
    dist[u] = 0;
    vis[u] = true;
    queue<int> q;
    q.push(u);
    while (!q.empty()) {
        int t = q.front();
        q.pop();
        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            if (!vis[j]) {  // 不要漏了
                vis[j] = true;
                q.push(j);
                dist[j] = dist[t] + 1;
            }
        }
    }
    return dist[n];
}
```

### Dijkstra 堆优化
稀疏图的时候使用
常用 时间复杂度 O(mlogn)

```c++
#include <bits/stdc++.h>
using namespace std;
typedef pair<int, int> PII;

const int N = 1e5 + 10;
int h[N], e[N], w[N], ne[N], idx;
int dist[N], vis[N];
int n, m;

void add(int a, int b, int c) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx, w[idx++] = c;
}

int dijkstra(int u) {
    memset(dist, 0x3f, sizeof dist);
    priority_queue<PII, vector<PII>, greater<PII>> q;
    // 初始化循环不变式
    dist[u] = 0;
    q.push({dist[u], u});
    while (!q.empty()) {
        auto t = q.top();
        q.pop();

        int ver = t.second, d = t.first;
        if (vis[ver]) continue;    // 因为不是索引堆，所以更新边是直接插入，所有有可能会有冗余边！！！
        
        vis[ver] = 1;
        dist[ver] = d;
        for (int i = h[ver]; i != -1; i = ne[i]) {
            int j = e[i];
            if (!vis[j] && dist[j] > dist[ver] + w[i]) {   // 对于所有未走过且经过ver的节点j，都更新从起点u到ver，再从ver到j的距离是否更短
                dist[j] = dist[ver] + w[i];
                q.push({dist[j], j});
            }
        }
    }
    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

int main() {
    memset(h, -1, sizeof h);
    scanf("%d%d", &n, &m);
    for (int i = 0; i < m; i++) {
        int a, b, c; scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }
    int ans = dijkstra(1);
    printf("%d", ans);
    return 0;
}
```