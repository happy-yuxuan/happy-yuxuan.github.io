---
title: 并查集
date: 2019-5-13 22:09:02
categories:
- [算法, 图论]
tags:
- 编程
---


# 并查集算法实现总结

### 朴素版并查集

* 询问两个元素是否在同一个集合
* 有多少个集合

```c++
int p[N];    // 下标i为节点编号，p[i]表示该节点的祖宗节点是谁(父辈中任意的一个)

// 初始化
void initUF() {
    for (int i = 0; i < n; i++) {
        p[i] = i;    // 每个节点的祖宗都是自己，自己单独成为一个集合
    }
}

// 查：  查找元素所在集合 --- 找到自己最老的祖宗，即根祖宗
int findR(int x) {
    if (x != p[x]) {
        p[x] = findR(p[x]);
    }
    return p[x];
}

// 查 简化写法
int findR(int x) {
    return p[x] == x ? x : p[x] = findR(p[x]);
}

// 并：   合并两个节点所在集合
void Union(int a, int b) {
    int ra = findR(a);
    int rb = findR(b);
    if (ra != rb) {
        p[rb] = ra;    // 把b所在集合接到a所在集合
    }
}
```

#### vector版本

```c++
vector<int> p(n);

// init
iota(p.begin(), p.end(), 0);

// find 
int findR(intx x) {
    return p[x] == x ? x : p[x] = findR(p[x]);
}

// Union
void Union(int a, int b) {
    p[findR(b)] = p[findR(a)];
}

```


### 维护rootSize的并查集 (可拓展维护集合的所有信息，都可以类似这样写)

```c++
int p[N], rootSize[N];    // rootSize[i]表示i节点所在集合的元素个数， 只有根祖宗的数值才有意义

void initUF() {
    for (int i = 0; i < n; i++) {
        p[i] = i;
        rootSize[i] = 1;    // 开始每个节点是独立的集合，所以大小为1
    }
}

int findR(int x) {
    if (x != p[x]) {
        p[x] = findR(p[x]);
    }
    return p[x];
}

void Union(int a, int b) {
    int ra = findR(a);
    int rb = findR(b);
    if (ra != rb) {
        rootSize[ra] += rootSize[rb];    // 在把rb接到ra之前先把rb整个元素大小都送给ra
        p[rb] = ra;
    }
}
```


### 获取结构信息
```c++
// 询问两个元素是否在同一个集合
bool isConnected(int a, int b) {
    return findR(a) == findR(b);
}

// 每个根祖宗的p[]指向得都是自己
int sizeOfUF() {
    int res = 0;
    for (int i = 0; i < n; i++) {
        if (p[i] == i) res++;
    }
    return res;
}
```


