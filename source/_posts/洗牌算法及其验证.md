---
title: 洗牌算法及其验证
date: 2020-03-04 16:52:43
categories:
- [算法, 数学]
tags:
- 编程

---



## 洗牌

分析洗牌算法正确性的准则：**产生的结果必须有 n! 种可能**，否则就是错误的。**这个很好解释，因为一个长度为 n 的数组的全排列就有 n! 种，也就是说打乱结果总共有 n! 种。算法必须能够反映这个事实，才是正确的。

```c++
void shuffle(int[] arr) {
    int n = arr.length();
    for (int i = 0 ; i < n; i++) {
        int rand = randInt(i, n - 1);  // 从 i 到最后随机选一个元素
        swap(arr[i], arr[rand]);
    }
}
```

* 对于每一个位置来说当前都有`i+i`中选法，即第0个位置有n中可能（0到n-1有n个数），第二个位置有n-1种可能以此类推。最后就有n!种可能。



## 验证

洗牌算法，或者说随机乱置算法的**正确性衡量标准是：对于每种可能的结果出现的概率必须相等，也就是说要足够随机。**

* 蒙特卡罗方法近似地估计出概率是否相等

  思想：类似求圆周率打点一样。在正方形纸上画一个直径为正方形边长的圆。随机往上扔石头，然后根据石头落在圆的内和圆外的数量即可估算出圆周率。

  *PS:这其实就是利用了蒙特卡罗方法：当打的点足够多的时候，点的数量就可以近似代表图形的面积。通过面积公式，由正方形和圆的面积比值是可以很容易推出圆周率的。当然打的点越多，算出的圆周率越准确*.

* 所以可以这样想，arr 数组中全都是 0，只有一个 1。我们对 arr 进行 100 万次打乱，记录每个索引位置出现 1 的次数，如果每个索引出现的次数差不多，也可以说明每种打乱结果的概率是相等的。

```java
void shuffle(int[] arr);

// 蒙特卡罗方法
int N = 1000000;    
int[] arr = {1,0,0,0,0};
int[] count = new int[arr.length];
for (int i = 0; i < N; i++) {
    shuffle(arr); // 打乱 arr
    for (int j = 0; j < arr.length; j++) 
        if (arr[j] == 1) {
            count[j]++;
            break;
        }
}
for (int feq : count) 
    print(feq / N + " "); // 频率
```



## 对应题目

[384. 打乱数组](https://leetcode-cn.com/problems/shuffle-an-array/)