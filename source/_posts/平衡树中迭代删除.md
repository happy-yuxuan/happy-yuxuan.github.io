---
title: STL平衡树中迭代删除的坑
date: 2020-03-09 02:02:20
categories:
- [C++, STL]
tags:
- 编程

---

# STL平衡树中迭代删除的坑



*昨天在map中在使用反向迭代器过程中删除的时候引发一些问题。死循环或者段错误，顾总结一下这个坑*



## 正向遍历删除

倘若有一个需求让你在map中操作，按key**从小到大**遍历，把全部key对应的value值为2的key从map中删除。

先上结论：

```c++
// 正确写法
for (auto it = mp.begin(); it != mp.end(); ) {
    if (it->second == 2)
        mp.erase(it++);
    else 
        it++;   // c++11后可以用 it = next(it);
}
```



```c++
// 错误写法
for (auto it = mp.begin(); it != mp.end(); it++) {
    if (it->second == 2)
        mp.erase(it);
}
```



* 对 list 和 vector 来说，它们的 erase 函数会返回下一个迭代器，因此在遍历时，只需要 `it = c.erase(it)` 即可。



* 对 map 和 set 来说，它们的 erase 函数返回的 void，而在进行 erase 之后，**当前迭代器会失效，无法再用于获取下一个迭代器**。因此需要 erase 之前就获取指向下一个元素的迭代器。如： 

  ```c++
  auto tmpIt = it;
  ++it;
  mp.erase(tmpIt);
  ```

  ```c++
  // 利用后缀++操作符的特性（先创建副本，然后再递增迭代器，然后返回副本）
  //上面的三行代码可以简化为一行：
  mp.erase(it++);
  ```

  

## 逆向删除

同样问题，只是改成从大到小遍历：倘若有一个需求让你在map中操作，按key**从大到小**遍历，把全部key对应的value值为2的key从map中删除。

```c++
// 正确写法
for (auto rit = mp.rbegin(); rit != mp.rend(); ) {
    if (rit->second == 2)
        mp.erase(--(rit.base()));  // c++ 11可以使用 mp.erase(next(rit).base());
    else 
        rit++;
}
```



原理解释： 借用一个图来说明问题

![](https://i.cmpnet.com/ddj/cuj/images/cuj0106smeyers/diagram2.gif)





首先， erase函数是**不接受反向迭代器作为参数**， 所以需要转化成正向迭代器进行传入。

其次， *关于正向/反向迭代器的关系，请参考《Effective STL》*两者**相差一个元素**，从一个**反向迭代器获得对应的正向迭代器**需要使用 `base()`方法。如下图所示：ri 是指向元素3的反向迭代器，而` i `是`ri.base()`所得到的正向迭代器。

最后，需要对得到的i进行自减操作，就会到3这个位置，从而进行删除。

```c++
mp.erase(--(rit.base()));   // 先获得正向迭代器，再--操作偏移一个得到当前所在的位置
```

```c++
// c++11可以写成
mp.erase(next(rit).base());   // 或者rit先向左边走一格，在取base()也可以

// 但不能写成，有大神可以告诉我为什么吗？ 待定解决问题
mp.erase((++rit).base());   // 在删除剩下的最后一个数的时候会死循环 
```



> **参考文献**：[stack overflow连接 ](https://stackoverflow.com/questions/1830158/how-to-call-erase-with-a-reverse-iterator)

