<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++之this指针</title>
    <link href="/2020/02/29/C-%E4%B9%8Bthis%E6%8C%87%E9%92%88/"/>
    <url>/2020/02/29/C-%E4%B9%8Bthis%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h3 id="this-pointer-指针-in-C"><a href="#this-pointer-指针-in-C" class="headerlink" title="this pointer(指针) in C++"></a><code>this</code> pointer(指针) in C++</h3><ul><li>每一个类的对象来说，成员属性是在每个对象是一个是副本。</li><li>而对于每个对象是共享一个类的成员函数。（this是解决区分谁调用了这个成员函数）</li></ul><p>通俗来说，this指针是用来区分哪一个对象。this指针作为隐藏参数传递给所有非静态成员变量函数调用，而且可以用作所有<strong>非静态函数体</strong>内部的局部变量。</p><p><em>静态函数是不能访问有this指针的，他是属于类的。</em></p><h4 id="作用1"><a href="#作用1" class="headerlink" title="作用1"></a>作用1</h4><p>初始化对象的成员变量(本地变量与成员变量重名的时候，当然不重名的时候也可以使用)</p><pre><code class="lang-c++">#include&lt;iostream&gt; using namespace std; /* local variable is same as a member&#39;s name */class Test { private:    int x; public:    void setX (int x)    {        // The &#39;this&#39; pointer is used to retrieve the object&#39;s x        // hidden by the local variable &#39;x&#39;        this-&gt;x = x;    }    void print() { cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; endl; } }; int main() {    Test obj;    int x = 20;    obj.setX(x);    obj.print();   // 输出结果：x = 20   return 0; }</code></pre><h4 id="作用2"><a href="#作用2" class="headerlink" title="作用2"></a>作用2</h4><p>返回调用对象的引用（从而可以链式设置等）</p><pre><code class="lang-c++">/* Reference to the calling object can be returned */ Test&amp; Test::func () {    // Some processing    return *this; }</code></pre><p>注意这里成员函数<code>func</code>返回的引用 <code>&amp;</code></p><pre><code class="lang-c++">#include&lt;iostream&gt; using namespace std; class Test { private:   int x;   int y; public:   Test(int x = 0, int y = 0) { this-&gt;x = x; this-&gt;y = y; }   Test &amp;setX(int a) { x = a; return *this; }  // 返回对象引用  Test &amp;setY(int b) { y = b; return *this; }  // 返回对象引用  void print() { cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot; y = &quot; &lt;&lt; y &lt;&lt; endl; } }; int main() {   Test obj1(5, 5);   // Chained function calls.  All calls modify the same object   // as the same object is returned by reference   obj1.setX(10).setY(20);   // 链式设置  obj1.print();  // 输出结果：x = 10 y = 20  return 0; }</code></pre><h4 id="作用3"><a href="#作用3" class="headerlink" title="作用3"></a>作用3</h4><p>删除对象</p><pre><code class="lang-c++">#include&lt;iostream&gt; using namespace std; class Test { private:   int x;   int y; public:   Test(int x = 0, int y = 0) { this-&gt;x = x; this-&gt;y = y; }   void setX(int a) { x = a; }   void setY(int b) { y = b; }   void destroy()  { delete this; }  // 删除这个对象调用各个成员变量的析构方法  void print() { cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; &quot; y = &quot; &lt;&lt; y &lt;&lt; endl; } }; int main() {   Test obj;   obj.print();   // print()一定要在destroy之前  obj.destroy();   // 删除掉了obj所指的对象  return 0; }</code></pre><h4 id="刷LeetCode时候规范用法"><a href="#刷LeetCode时候规范用法" class="headerlink" title="刷LeetCode时候规范用法"></a>刷LeetCode时候规范用法</h4><p>把函数参数赋值给<code>this-&gt;成员属性</code>，这样可以再任何地方使用成员属性，就不用作为引用参数传入了。</p><pre><code class="lang-c++">class Solution {private:    vector&lt;vector&lt;int&gt;&gt; a;  // 自己定义成员变量    int n, m;  // // 自己定义成员变量    void solve() {        a[0][0] = 1;        // ... 正常使用a, m, n    }public:      int getMaximumGold(vector&lt;vector&lt;int&gt;&gt;&amp; a) {        this-&gt;a = a;    // 把本地变量赋值给同名的数据成员(data member)        this-&gt;n = a.size(), this-&gt;m = a[0].size();  // // 把本地变量赋值给同名的数据成员(data member)        solve();        // 操作逻辑...        //return ans;    }};</code></pre><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://www.geeksforgeeks.org/this-pointer-in-c/" target="_blank" rel="noopener">geeksforgeeks</a> </p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并查集</title>
    <link href="/2019/05/13/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <url>/2019/05/13/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="并查集算法实现总结"><a href="#并查集算法实现总结" class="headerlink" title="并查集算法实现总结"></a>并查集算法实现总结</h1><h3 id="朴素版并查集"><a href="#朴素版并查集" class="headerlink" title="朴素版并查集"></a>朴素版并查集</h3><ul><li>询问两个元素是否在同一个集合</li><li>有多少个集合</li></ul><pre><code class="lang-c++">int p[N];    // 下标i为节点编号，p[i]表示该节点的祖宗节点是谁(父辈中任意的一个)// 初始化void initUF() {    for (int i = 0; i &lt; n; i++) {        p[i] = i;    // 每个节点的祖宗都是自己，自己单独成为一个集合    }}// 查：  查找元素所在集合 --- 找到自己最老的祖宗，即根祖宗int findR(int x) {    if (x != p[x]) {        p[x] = findR(p[x]);    }    return p[x];}// 查 简化写法int findR(int x) {    return p[x] == x ? x : p[x] = findR(p[x]);}// 并：   合并两个节点所在集合void Union(int a, int b) {    int ra = findR(a);    int rb = findR(b);    if (ra != rb) {        p[rb] = ra;    // 把b所在集合接到a所在集合    }}</code></pre><h4 id="vector版本"><a href="#vector版本" class="headerlink" title="vector版本"></a>vector版本</h4><pre><code class="lang-c++">vector&lt;int&gt; p(n);// initiota(p.begin(), p.end(), 0);// find int findR(intx x) {    return p[x] == x ? x : p[x] = findR(p[x]);}// Unionvoid Union(int a, int b) {    p[findR(b)] = p[findR(a)];}</code></pre><h3 id="维护rootSize的并查集-可拓展维护集合的所有信息，都可以类似这样写"><a href="#维护rootSize的并查集-可拓展维护集合的所有信息，都可以类似这样写" class="headerlink" title="维护rootSize的并查集 (可拓展维护集合的所有信息，都可以类似这样写)"></a>维护rootSize的并查集 (可拓展维护集合的所有信息，都可以类似这样写)</h3><pre><code class="lang-c++">int p[N], rootSize[N];    // rootSize[i]表示i节点所在集合的元素个数， 只有根祖宗的数值才有意义void initUF() {    for (int i = 0; i &lt; n; i++) {        p[i] = i;        rootSize[i] = 1;    // 开始每个节点是独立的集合，所以大小为1    }}int findR(int x) {    if (x != p[x]) {        p[x] = findR(p[x]);    }    return p[x];}void Union(int a, int b) {    int ra = findR(a);    int rb = findR(b);    if (ra != rb) {        rootSize[ra] += rootSize[rb];    // 在把rb接到ra之前先把rb整个元素大小都送给ra        p[rb] = ra;    }}</code></pre><h3 id="获取结构信息"><a href="#获取结构信息" class="headerlink" title="获取结构信息"></a>获取结构信息</h3><pre><code class="lang-c++">// 询问两个元素是否在同一个集合bool isConnected(int a, int b) {    return findR(a) == findR(b);}// 每个根祖宗的p[]指向得都是自己int sizeOfUF() {    int res = 0;    for (int i = 0; i &lt; n; i++) {        if (p[i] == i) res++;    }    return res;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图的构建</title>
    <link href="/2019/05/12/%E5%9B%BE%E7%9A%84%E6%9E%84%E5%BB%BA/"/>
    <url>/2019/05/12/%E5%9B%BE%E7%9A%84%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="树-amp-图"><a href="#树-amp-图" class="headerlink" title="树 &amp; 图"></a>树 &amp; 图</h1><ul><li>树是特殊的图， 无向图是特殊的有向图，所以只需要研究有向图的即可</li></ul><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>(稠密图使用， N^2 跟M是一个规模的时候才使用)<br><strong>优点：</strong> 找任意两点是否连通块， 可以多存一维的信息，如g[i][j]可以代表权重  </p><h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><pre><code class="lang-c++">int g[N][N];    // LeetCode 这样给出 vector&lt;vector&lt;int&gt;&gt; edge// g[a][b] 存储边a-&gt;bvoid add(int a, int b) {    g[a][b] = 1;    // g[b][a] = 1;}</code></pre><ul><li>处理自环和重边， 只需要保留最小的一条边就可以了</li></ul><h3 id="Dijkstra朴素版本"><a href="#Dijkstra朴素版本" class="headerlink" title="Dijkstra朴素版本"></a>Dijkstra朴素版本</h3><p>朴素算法: 适合使用邻接矩阵，在边数特别多的时候才使用邻接矩阵的朴素版本<br>时间复杂度为 O( N^2 )  因为n比较小所以使用</p><p>思路：</p><ol><li>把出发点u设置成0 dist[u] = 0， 其余点都设置成为 正无穷</li><li>迭代n次(n为节点个数) 将没有确定的点里出发点u最近的点找出来，设为t；</li><li>t加入确定的点中</li><li>用t更新 跟t连接的点的距离(从出发点到该点， 还是t作为中介点)</li></ol><p>从1点到n点的最小值。 Acwing 849</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 510;int g[N][N], n, m;int dist[N], vis[N];void add(int a, int b, int c) {    g[a][b] = min(g[a][b], c);}int dijkstra(int u) {    memset(dist, 0x3f, sizeof dist);    // 记得每次先初始化距离    dist[u] = 0;    for (int i = 0; i &lt; n; i++) {    // 进行n次迭代，每次迭代加入一个点        int t = -1;        for (int j = 1; j &lt;= n; j++) {            if (!vis[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) {                t = j;            }        }        vis[t] = 1;        for (int j = 1; j &lt;= n; j++) {            dist[j] = min(dist[j], dist[t] + g[t][j]);        }    }    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];}int main() {    memset(g, 0x3f, sizeof g);    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 0; i &lt; m; i++) {        int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);        add(a, b, c);    }    int ans = dijkstra(1);    printf(&quot;%d\n&quot;, ans);    return 0;}</code></pre><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>(稀疏图使用 N跟M的规模差不多的时候) 使用较多</p><p><strong>优点：</strong> 找一个顶点的所有边比较快， 省空间， 可以有重边</p><h3 id="构建-1"><a href="#构建-1" class="headerlink" title="构建"></a>构建</h3><p>使用一个单链表(静态)，把每个节点对应的边组成一条链。 h[k] 存储这个顶点k的边链的头结点</p><pre><code class="lang-c++">/** * 节点维度 N个顶点 * h[i] 对应节点中边链中一个的地址 *  * 边维度 M 最多有 N*(N-1)条边 每一个节点都跟另外N-1个顶点有边 * e[] 地址对应的node元素是几号，即这个地址对应的元素编号 * ne[] 下一条边的地址 * inx 边的数量，一直指向最后添加进来的一条边的地址。 idx是对应元素的地址 */int h[N], e[M], ne[M], idx;void add(int a, int b) {    e[idx] = b; ne[idx] = h[a], h[a] = idx++;}// !!!!务必记得初始化memset(h, -1, sizeof h);idx = 0; // 全局变量自动为0</code></pre><h3 id="遍历一个顶点的所有边"><a href="#遍历一个顶点的所有边" class="headerlink" title="遍历一个顶点的所有边"></a>遍历一个顶点的所有边</h3><p>遍历6号顶点的所有边</p><pre><code class="lang-c++">for (int i = h[6]; i != -1; i = ne[i]) {    cout &lt;&lt; e[i] &lt;&lt; &quot; &quot;;    // e[i]为顶点编号}</code></pre><h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><ul><li>一条路走到黑, 可以带返回值上来</li></ul><pre><code class="lang-c++">// 返回以u为根节点的子树的大小 Acwing846题int dfs(int u) {    vis[u] = 1;    int size = 1, king = 0;    for (int i = h[u]; i != -1; i = ne[i]) {        int child = e[i];        if (!vis[child]) {            int t = dfs(child);            king = max(king, t);            size += t;        }    }    king = max(king, n - size);    ans = min(ans, king);    return size;}</code></pre><h3 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h3><p>把bfs 算法应用于无权图，或者所有边的权都相等的图，bfs搜索等同于Dijkstra算法。</p><pre><code class="lang-c++">int h[N], e[N], ne[N], idx;bool vis[N];int dist[N];// 计算u节点到n节点的最短距离(无权图距离都是1)int bfs(int u) {    memset(dist, -1, sizeof dist);    dist[u] = 0;    vis[u] = true;    queue&lt;int&gt; q;    q.push(u);    while (!q.empty()) {        int t = q.front();        q.pop();        for (int i = h[t]; i != -1; i = ne[i]) {            int j = e[i];            if (!vis[j]) {  // 不要漏了                vis[j] = true;                q.push(j);                dist[j] = dist[t] + 1;            }        }    }    return dist[n];}</code></pre><h3 id="Dijkstra-堆优化"><a href="#Dijkstra-堆优化" class="headerlink" title="Dijkstra 堆优化"></a>Dijkstra 堆优化</h3><p>稀疏图的时候使用<br>常用 时间复杂度 O(mlogn)</p><pre><code class="lang-c++">#include &lt;bits/stdc++.h&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 1e5 + 10;int h[N], e[N], w[N], ne[N], idx;int dist[N], vis[N];int n, m;void add(int a, int b, int c) {    e[idx] = b, ne[idx] = h[a], h[a] = idx, w[idx++] = c;}int dijkstra(int u) {    memset(dist, 0x3f, sizeof dist);    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; q;    // 初始化循环不变式    dist[u] = 0;    q.push({dist[u], u});    while (!q.empty()) {        auto t = q.top();        q.pop();        int ver = t.second, d = t.first;        if (vis[ver]) continue;    // 因为不是索引堆，所以更新边是直接插入，所有有可能会有冗余边！！！        vis[ver] = 1;        dist[ver] = d;        for (int i = h[ver]; i != -1; i = ne[i]) {            int j = e[i];            if (!vis[j] &amp;&amp; dist[j] &gt; dist[ver] + w[i]) {   // 对于所有未走过且经过ver的节点j，都更新从起点u到ver，再从ver到j的距离是否更短                dist[j] = dist[ver] + w[i];                q.push({dist[j], j});            }        }    }    if (dist[n] == 0x3f3f3f3f) return -1;    return dist[n];}int main() {    memset(h, -1, sizeof h);    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 0; i &lt; m; i++) {        int a, b, c; scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);        add(a, b, c);    }    int ans = dijkstra(1);    printf(&quot;%d&quot;, ans);    return 0;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>层次遍历</title>
    <link href="/2019/02/20/%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    <url>/2019/02/20/%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树层次遍历模板"><a href="#二叉树层次遍历模板" class="headerlink" title="二叉树层次遍历模板"></a>二叉树层次遍历模板</h1><h3 id="模板一：以每层为单位操作"><a href="#模板一：以每层为单位操作" class="headerlink" title="模板一：以每层为单位操作"></a>模板一：以每层为单位操作</h3><pre><code class="lang-c++">vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {    vector&lt;vector&lt;int&gt;&gt; ans;    if (!root) return ans;    queue&lt;TreeNode*&gt; q;    q.push(root);    while (!q.empty()) {        int siz = q.size();  // 记录当前层有多少个节点        vector&lt;int&gt; level;        for (int i = 0; i &lt; siz; i++) {  // 让当前层的节点出队， 把下一层的节点放入队列中            auto t = q.front(); q.pop();            level.push_back(t-&gt;val);            if (t-&gt;left) q.push(t-&gt;left);            if (t-&gt;right) q.push(t-&gt;right);        }        ans.push_back(level);    }    return ans;}</code></pre><h3 id="模板二：以每个节点为单位，使用pair放入队列记录层数"><a href="#模板二：以每个节点为单位，使用pair放入队列记录层数" class="headerlink" title="模板二：以每个节点为单位，使用pair放入队列记录层数"></a>模板二：以每个节点为单位，使用pair放入队列记录层数</h3><pre><code class="lang-c++">vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {    vector&lt;vector&lt;int&gt;&gt; ans;    if (!root) return ans;    queue&lt;PTI&gt; q;    q.push({root, 0});    while (!q.empty()) {        auto t = q.front(); q.pop();        TreeNode *p = t.first;        int level = t.second;        // 把下一层新建出来  记得不能写成ans.size() - 1 &lt; level。 要写成 (int)ans.size() - 1 &lt; level        if (ans.size() &lt; level + 1)  ans.push_back(vector&lt;int&gt;());        ans[level].push_back(p-&gt;val);        if (p-&gt;left) q.push({p-&gt;left, level + 1});        if (p-&gt;right) q.push({p-&gt;right, level + 1});    }    return ans;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调队列</title>
    <link href="/2019/02/20/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    <url>/2019/02/20/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><h3 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h3><ul><li>维护一个具有<strong>单调性质的双端队列</strong>（头尾均可添加删除）， 因为有一些答案永远不会成为答案，所以把其覆盖掉，并使得队列单调， 即可以使用单调队列。 </li></ul><h3 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h3><h4 id="滑动窗口最小值和最大值"><a href="#滑动窗口最小值和最大值" class="headerlink" title="滑动窗口最小值和最大值"></a><a href="https://www.acwing.com/problem/content/156/" target="_blank" rel="noopener">滑动窗口最小值和最大值</a></h4><ul><li><p>以最大值为例（最小值同理）</p><p>对于每一个滑动窗口而言，若来了一个新进来的数字，这个数字若都大于等于之前的数，说明之前的数都不可能是答案，因为新加进来的元素已经比他们大，所以不可能是答案。</p><pre><code class="lang-c++">deque&lt;int&gt; q;  // 存放下标// 枚举以每个结束的区间[0, i]for (int i = 0; i &lt; n; i++) {    // 判断队头是否已经被划出窗口    if (!q.empty() &amp;&amp; i - k + 1 &gt; q.front()) q.pop_front();    // 维护单调队列，把小于当前数的所有下标尾出队    while (!q.empty() &amp;&amp; nums[q.back()] &lt;= nums[i]) q.pop_back();    q.push_back(i);     if (i &gt;= k - 1) printf(&quot;%d &quot;, nums[q.front()]);  // [0,k-1]才是第一个区间，开始记录答案}</code></pre></li></ul><h4 id="面试题59-II-队列的最大值"><a href="#面试题59-II-队列的最大值" class="headerlink" title="面试题59 - II. 队列的最大值"></a><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">面试题59 - II. 队列的最大值</a></h4><pre><code class="lang-c++">class MaxQueue {private:    queue&lt;int&gt; q;    deque&lt;int&gt; help;public:    MaxQueue() {}    int max_value() {        return help.empty() ? -1 : help.front();    }    void push_back(int value) {        q.push(value);        while (!help.empty() &amp;&amp; help.back() &lt; value) help.pop_back();        help.push_back(value);    }    int pop_front() {        if (q.empty()) return -1;        int x = q.front(); q.pop();        if (x == help.front()) help.pop_front();        return x;    }};</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>非递归前中后遍历总结</title>
    <link href="/2019/02/20/%E5%89%8D%E4%B8%AD%E5%90%8E%E9%81%8D%E5%8E%86/"/>
    <url>/2019/02/20/%E5%89%8D%E4%B8%AD%E5%90%8E%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="非递归前中后遍历总结"><a href="#非递归前中后遍历总结" class="headerlink" title="非递归前中后遍历总结"></a>非递归前中后遍历总结</h1><ul><li>对于一个二叉树而言，前中后遍历分别对应第1，2，3次访问该节点。如在第一次访问该节点输出就是前序遍历，第二次访问该节点就是中序遍历，第三次访问该节点就是后序遍历。 在网上找到一张有意思的图。</li></ul><p><img src="/img/IMG_0065.jpg" srcset="/img/loading.gif" alt=""></p><h2 id="用中序遍历的思想实现前后遍历"><a href="#用中序遍历的思想实现前后遍历" class="headerlink" title="用中序遍历的思想实现前后遍历"></a>用中序遍历的思想实现前后遍历</h2><p>(常用遍历技巧)</p><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><pre><code class="lang-c++">vector&lt;int&gt; preorderTraversal(TreeNode* root) {    vector&lt;int&gt; ans;    stack&lt;TreeNode*&gt; stk;    auto p = root;    while (p || !stk.empty()) {        while (p) {            ans.push_back(p-&gt;val);  // 前序遍历 ①            stk.push(p);            p = p-&gt;left;        }        p = stk.top(); stk.pop();            p = p-&gt;right;    }    return ans;}</code></pre><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><pre><code class="lang-c++">vector&lt;int&gt; inorderTraversal(TreeNode* root) {    vector&lt;int&gt; ans;    stack&lt;TreeNode*&gt; stk;    auto p = root;    while (p || !stk.empty()) {        while (p) {            stk.push(p);            p = p-&gt;left;        }        p = stk.top(); stk.pop();        ans.push_back(p-&gt;val);  // 中序遍历 ②        p = p-&gt;right;    }    return ans;}</code></pre><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>经典例题：<a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. 路径总和 II</a> 的非递归写法</p><pre><code class="lang-c++">vector&lt;int&gt; postorderTraversal(TreeNode* root) {        vector&lt;int&gt; ans;        stack&lt;TreeNode*&gt; stk;        TreeNode* p = root, *prev = nullptr;  // prev 来标记上一个访问的节点        while (p || !stk.empty()) {            while (p) {                stk.push(p);                p = p-&gt;left;            }            p = stk.top();            // 右儿子是空 或 这已经访问过右儿子了 说明可以访问当前这个根节点了（③）            if (!p-&gt;right || p-&gt;right == prev) {                ans.push_back(p-&gt;val);   // 后序遍历 ③                stk.pop();                prev = p;  // 标记已访问                p = nullptr;  // 用于回溯到上一级            } else {                p = p-&gt;right;  // 递归访问右子树            }        }        return ans;    }</code></pre><h2 id="传统方法"><a href="#传统方法" class="headerlink" title="传统方法"></a>传统方法</h2><p>（N叉树也适用， N叉树没有中序遍历）</p><h3 id="前序遍历（根-左-右）"><a href="#前序遍历（根-左-右）" class="headerlink" title="前序遍历（根 左 右）"></a>前序遍历（根 左 右）</h3><pre><code class="lang-c++">vector&lt;int&gt; preorderTraversal(TreeNode* root) {    vector&lt;int&gt; ans;    if (!root) return ans;    stack&lt;TreeNode*&gt; stk;    stk.push(root);    while (!stk.empty()) {        auto t = stk.top(); stk.pop();        ans.push_back(t-&gt;val); // 输出根        // 根 stack(右 左) == 根 左 右        // 右子树先压栈，等左子树都访问完再访问右子树        if (t-&gt;right) stk.push(t-&gt;right);         if (t-&gt;left) stk.push(t-&gt;left);    }    return ans;}</code></pre><h3 id="中序遍历（左-根-右）"><a href="#中序遍历（左-根-右）" class="headerlink" title="中序遍历（左 根 右）"></a>中序遍历（左 根 右）</h3><pre><code class="lang-c++">vector&lt;int&gt; inorderTraversal(TreeNode* root) {    vector&lt;int&gt; ans;    stack&lt;TreeNode*&gt; stk;    auto p = root;    while (p || !stk.empty()) {        while (p) {  // 让p走到最左边的节点            stk.push(p); // 路上的结点根, 等子树的左边(以及其子树)访问完在访问，所以压到栈中            p = p-&gt;left;        }        // p最左边的节点        p = stk.top(), stk.pop();        ans.push_back(p-&gt;val);  // 中序遍历 ②        p = p-&gt;right;  // 对其右子树遍历    }    return ans;}</code></pre><h3 id="后序遍历-（左-右-根）"><a href="#后序遍历-（左-右-根）" class="headerlink" title="后序遍历 （左 右 根）"></a>后序遍历 （左 右 根）</h3><ul><li>（左 右 根） 反过来就是 （根 右 左）</li><li>先用类似前序遍历（根 左 右）变成 （根 右 左）的方法遍历， 然后把答案逆置</li></ul><pre><code class="lang-c++">vector&lt;int&gt; postorderTraversal(TreeNode* root) {    vector&lt;int&gt; ans;    if (!root) return ans;    stack&lt;TreeNode*&gt; stk;    stk.push(root);    while (!stk.empty()) {        auto t = stk.top(); stk.pop();        ans.push_back(t-&gt;val);        // 根 右 左        // 先把 左子树压栈，等右子树都访问完在访问        if (t-&gt;left) stk.push(t-&gt;left);        if (t-&gt;right) stk.push(t-&gt;right);    }    reverse(ans.begin(), ans.end());    return ans;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2019/02/05/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <url>/2019/02/05/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><h3 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h3><ul><li>维护一个具有<strong>单调性质的栈</strong>， 因为有一些答案永远不会成为答案，所以把其覆盖掉，并使得栈单调， 即可以使用单调栈。</li></ul><h3 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h3><h4 id="单调栈-1"><a href="#单调栈-1" class="headerlink" title="单调栈"></a><a href="https://www.acwing.com/problem/content/832/" target="_blank" rel="noopener">单调栈</a></h4><ul><li>只要当数小于等于栈顶元素， 则栈顶元素不可能是答案， 因为当前数比栈顶元素小。所以出栈出到第一个比当前数小的数为止，该数为第一个比当前nums[i]小的数。记得把nums[i]插入栈顶作为新的一轮。</li></ul><pre><code class="lang-c++">for (int i = 0; i &lt; n; i++) {    while (!stk.empty() &amp;&amp; nums[i] &lt;= stk.top()) {        stk.pop();    }    if (stk.empty()) {   // 左边没有比他小的元素        printf(&quot;-1 &quot;);    } else {   // 栈顶元素是第一个比他小的数        printf(&quot;%d &quot;, stk.top());    }    stk.push(nums[i]);}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拓扑排序</title>
    <link href="/2019/02/05/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/02/05/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><h3 id="算法思想：bfs"><a href="#算法思想：bfs" class="headerlink" title="算法思想：bfs"></a>算法思想：bfs</h3><ul><li>把所有入度为0的点全部放入队列。</li><li>只要有入度为0的节点（队列不为空）则把该点输出，并把以该点t为入度的所有节点的入度减一。</li><li>把每个入度被减成0的节点放入队列</li></ul><pre><code class="lang-c++">/*     n 节点个数，下标从1开始    graph 邻接表    inD 每个节点的入度    ans 保存拓扑序*/bool topsort() {    queue&lt;int&gt; q;    for (int i = 1; i &lt;= n; i++) // 把所有入度为0的点全部加进队列        if (inD[i] == 0)            q.push(i);    while (!q.empty()) {        int t = q.front(); q.pop();  // 拿一个入度为0的点        ans.push_back(t);        for (int v : graph[t])  // 把以该点t为入度的点的入度减一            if (--inD[v] == 0)                 q.push(v);  // 若减成0，则入队    }    return ans.size() == n;  // 若全部节点都被访问才说明有 拓扑序}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数论</title>
    <link href="/2019/02/04/%E6%95%B0%E8%AE%BA%E6%80%BB%E7%BB%93/"/>
    <url>/2019/02/04/%E6%95%B0%E8%AE%BA%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>库函数： <code>res = pow(x, n)</code> </p><pre><code class="lang-c++">// n 不能是INT_MIN, 因为负数转成正数做会溢出，要单独判断double pow(double x, int n) {    if (n &lt; 0) n = -n, x = 1/x;    double res = 1, t = x;    while (n) {        if (n &amp; 1) res *= t;        t *= t;        n &gt;&gt;= 1;    }    return res;}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>区间合并</title>
    <link href="/2019/02/03/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/"/>
    <url>/2019/02/03/%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h1><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h4 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">合并区间</a></h4><p> 思路：</p><ol><li><p>先对区间的左端点进行排序。</p></li><li><p>如果上一个区间的右端点 大于等于 当前区间的左端点， 则合并两个区间；否则，当前区间作为一个新的区间加入新区间。</p></li></ol><ul><li>新建一个数组保存区间</li></ul><pre><code class="lang-c++">class Solution {public:    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {        vector&lt;vector&lt;int&gt;&gt; ans;        if (intervals.size() &lt;= 1) {            ans = intervals;            return ans;        }        sort(intervals.begin(), intervals.end());        ans.push_back(intervals[0]);        for (int i = 1; i &lt; intervals.size(); i++) {            auto &amp;pre = ans.back();            auto cur = intervals[i];            if (pre[1] &gt;= cur[0]) {                 pre[1] = max(pre[1], cur[1]);            } else {                ans.push_back({cur});            }        }        return ans;    }};</code></pre><ul><li>原地</li></ul><pre><code class="lang-c++">class Solution {public:    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {        if (intervals.size() &lt;= 1) return intervals;        sort(intervals.begin(), intervals.end());        int cnt = 0;  // 当前区间的位置        for (int i = 1; i &lt; intervals.size(); i++) {            auto &amp;pre = intervals[cnt];            auto &amp;cur = intervals[i];            if (pre[1] &gt;= cur[0]) {                pre[1] = max(pre[1], cur[1]);            } else {                intervals[++cnt] = cur;            }        }        // 把后面多出来的删掉        int deleteTime = intervals.size() - 1 - cnt;        while (deleteTime--) intervals.pop_back();        return intervals;    }};</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>位运算</title>
    <link href="/2019/02/03/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <url>/2019/02/03/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p><code>1 &lt;&lt; n</code> 2的n次方</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><pre><code class="lang-c++">// 求n的第k位数字: n &gt;&gt; k &amp; 1// 返回n的最后一位1：（就是n的二进制表示最后一个1出现的位置是1， 其余位置都是0）int lowbit(int n) {    return n &amp; -n;}</code></pre><h2 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h2><h4 id="位1的个数"><a href="#位1的个数" class="headerlink" title="位1的个数"></a><a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">位1的个数</a></h4><ul><li>让n减lowbit操作的数（每次减掉了最末尾的1）， 减了多少次到0， 就是多少个1.</li></ul><pre><code class="lang-c++">class Solution {public:    uint32_t lowbit(uint32_t n) {        return n &amp; -n;    }    int hammingWeight(uint32_t n) {        int ans = 0;        for (uint32_t i = n; i != 0; i -= lowbit(i)) {            ans++;        }        return ans;    }};</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分</title>
    <link href="/2019/02/03/%E4%BA%8C%E5%88%86/"/>
    <url>/2019/02/03/%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><ul><li>主要看枚举哪一个点，根据这个点的性质到底使用哪个模板(右边的第一个点, 或左边的最后一个点)</li><li>二分的本质是左边满足一个性质，右边满足一个性质，就可以二分</li><li>看到是l = mid就要向上取整，即l + r + 1 &gt;&gt; 1</li></ul><pre><code class="lang-c++">bool check(int x) {/* ... */} // 检查x是否满足某种性质// ! 找性质在右半边的第一个点 !// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：(向下取整) int bsearch_1(int l, int r){    while (l &lt; r)    {        int mid = l + r &gt;&gt; 1;        if (check(mid)) r = mid;    // check()判断mid是否满足性质        else l = mid + 1;    }    return l;}// ! 找性质在左半边的最后一个点 !// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： (向上取整)int bsearch_2(int l, int r){    while (l &lt; r)    {        int mid = l + r + 1 &gt;&gt; 1;        if (check(mid)) l = mid;        else r = mid - 1;    }    return l;}</code></pre><h3 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h3><h5 id="数的范围"><a href="#数的范围" class="headerlink" title="数的范围"></a><a href="https://www.acwing.com/problem/content/791/" target="_blank" rel="noopener">数的范围</a></h5><pre><code class="lang-c++">int l = 0, r = n - 1;  // 从 [0, n-1]的范围二分while (l &lt; r) {    int mid = l + r &gt;&gt; 1;    if (a[mid] &gt;= k) r = mid;   // 找第一个大于等于k的位置    else l = mid + 1;}if (a[l] != k) {   // 找不到的情况返回 -1 -1    printf(&quot;-1 -1\n&quot;);    continue;}printf(&quot;%d &quot;, l);  // 得到第一个答案r = n - 1;   // 从[第一个大于等于k的位置, n - 1]while (l &lt; r) {    int mid = l + r + 1&gt;&gt; 1;    if (a[mid] &lt;= k) l = mid;   // 找最后一个小于等于k的位置    else r = mid - 1;}printf(&quot;%d\n&quot;, l);</code></pre><h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><pre><code class="lang-c++">bool check(double x) {/* ... */} // 检查x是否满足某种性质double bsearch_3(double l, double r){    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求 一般比题目高两个数量级    while (r - l &gt; eps)    {        double mid = (l + r) / 2;        if (check(mid)) r = mid;        else l = mid;    }    return l;}</code></pre><h3 id="经典例题-1"><a href="#经典例题-1" class="headerlink" title="经典例题"></a>经典例题</h3><h5 id="数的三次方根"><a href="#数的三次方根" class="headerlink" title="数的三次方根"></a><a href="https://www.acwing.com/problem/content/792/" target="_blank" rel="noopener">数的三次方根</a></h5><pre><code class="lang-c++">double l = -10000, r = 10000;while (r - l &gt;= 1e-7) {    double mid = (l + r) / 2;    if (mid * mid * mid &gt;= n) r = mid;    else l = mid;}printf(&quot;%.6lf&quot;, l);</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前缀和 &amp; 差分</title>
    <link href="/2019/02/03/%E5%89%8D%E7%BC%80%E5%92%8C&amp;%E5%B7%AE%E5%88%86/"/>
    <url>/2019/02/03/%E5%89%8D%E7%BC%80%E5%92%8C&amp;%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="前缀和-amp-差分"><a href="#前缀和-amp-差分" class="headerlink" title="前缀和 &amp; 差分"></a>前缀和 &amp; 差分</h1><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><h4 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h4><ul><li>s[i] 表示前i个数<code>[0, i)</code>的累加和。 下标从1开始。 (s[0] == 0) dp的边界， 可以少些判断</li><li>前缀和数组<code>s</code>下标从1开始， 原数组<code>nums</code>下标从0开始</li></ul><pre><code class="lang-c++">// s[0] = 0for (int i = 1; i &lt;= n; i++) {    s[i] = s[i-1] + nums[i-1];}// l, r是指原数组下标区间// s[r+1]: [0, r]       0, 1, ..., l-1 , l, ..., r// s[l]  : [0, l-1]     0, 1, ..., l-1 , // 相减                       [l, r]的和 ：l, ..., r                 int l_to_r_sum = s[r+1] - s[l];</code></pre><h4 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h4><pre><code class="lang-c++">// s下标从1开始（第0行和第0列都置成0）， mat下标从0开始// 算前缀和for (int i = 1; i &lt;= n; i++) {    for (int j = 1; j &lt;= m; j++) {        s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + mat[i-1][j-1];    }}// (x1, y1) 为左上角， (x2, y2)为右上角. 坐标对应原数组下标。 下标偏移了1int sum = s[x2+1][y2+1] - s[x1][y2+1] - s[x2+1][y1] + s[x1][y1];</code></pre><h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><h4 id="一维-1"><a href="#一维-1" class="headerlink" title="一维"></a>一维</h4><ul><li>所求数组s（下标从0开始）为一个数组的前缀和数组， 处前把其变成下标从1开始，让<code>s[0] == 0</code></li><li>求出原数组<code>nums</code></li><li>把原数组还原成s数组， 根据题目需要是否把s数组改回成下标从0开始</li></ul><pre><code class="lang-c++">// 让s[0] == 0for (int i = 1; i &lt;= n; i++) {    nums[i-1] = s[i] - s[i-1];   // 前缀和的逆运算 s[i] = s[i-1] + nums[i-1]}// 区间[l, r]增加一个数c ， l, r是从0开始的下标nums[l] += c;   //等价对应s数组 l... r, r+1, ..., n-1 全部增加了cnums[r+1] -= c; //等价对应s数组         r+1, ..., n-1 全部减少c                // s数组 [l, r] 增加了cfor (int i = 1; i &lt;= n; i++) {    s[i] = s[i-1] + nums[i-1]}// 再把s数字变成以0为下标// remove first item in array of s</code></pre><h4 id="二维-1"><a href="#二维-1" class="headerlink" title="二维"></a>二维</h4><pre><code class="lang-c++">// s原数组变成下标从1开始， 原来从0开始，（第0行和第0列都置成0）// 算差分数组mat， 下标从0开始， 但是mat数组也要开多一维for (int i = 1; i &lt;= n; i++) {    for (int j = 1; j &lt;= m; j++) {        mat[i-1][j-1] = s[i][j] - s[i-1][j] - s[i][j-1] + s[i-1][j-1];    }}mat[x1][y1] += c;mat[x2+1][y1] -= c;mat[x1][y2+1] -= c;mat[x2+1][y2+1] += c;  // 可能越界， 所以要开多一维，最后一行和最后一列都为0for (int i = 1; i &lt;= n; i++) {    for (int j = 1; j &lt;= m; j++) {        s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + mat[i-1][j-1];    }}// 还原s数组从0坐标开始</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双指针</title>
    <link href="/2019/02/03/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <url>/2019/02/03/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><ul><li>双指针的核心：将上一状态指针所表达的信息传递至下一状态，从而减少无谓的搜索。</li><li>一般尾指针是add，头指针是remove</li><li>一般提问求<strong>子串</strong>（区间）的<strong>最长、最短、数量</strong></li></ul><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul><li><p>对于一个序列，用两个指针维护一段区间(滑动窗口)， 可以相互转换。 <strong>（一般）判断最大的时候while里面</strong>。有边界情况的时候两个模板可以换着写，可能边界就会消失了。本人比较喜欢固定头</p><ul><li><p>固定尾指针:   i是新的尾指针， j是头指针 （移动的途中，即while循环中是满足条件的）</p><pre><code class="lang-c++">int j = 0;for (int i = 0; i &lt; n; i++) {    // add可能对i进行操作，因为i这个元素要被加入窗口    while (j &lt;= i &amp;&amp; check1()) j++;  // remove， 里面都是满足check的区间    // 第一个不满足check性质的区间}</code></pre></li><li><p>固定头指针， 一般来说两个check是相反的， 即<code>check1 == !check2</code></p><pre><code class="lang-c++">int j = 0;for (int i = 0; i &lt; n; i++) {  while (j &lt; n &amp;&amp; check2()) j++;  // add，里面都是满足check2的区间    if (!check2())  // 第一个不满足check2性质的区间. (只要j没有越界，但是j &lt;= n,因为j++了，不能写j&lt;=n会多出解)    // 可能对i进行操作，因为下一层循环i这个位置的元素要被移出窗口 remove}</code></pre></li></ul></li></ul><ul><li><p>对于两个序列，维护某种次序，比如一头一尾有序数组找和. 或归并排序中合并两个有序序列的操作</p><pre><code class="lang-c++">// 固定左指针for (int l = 0, r = n - 1; l &lt; r; l++) {    while (r &gt;= l &amp;&amp; check()) r--; }// 全局考虑，每次区间缩小int l = 0, r = n - 1;while (l &lt; r) {    /* 若找到满足性质的区间           返回这个区间                  若没找到：           每一次 l++ 或 r--;           每一次区间减少1            */}</code></pre></li></ul><h2 id="双指针经典题"><a href="#双指针经典题" class="headerlink" title="双指针经典题"></a>双指针经典题</h2><h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a></h4><ul><li>对于每一个较小的数下标i， 看离l最近的较大的数的下标j可以到哪里。较大的数具有单调性</li><li><p>这题同理在两个有序数组中找等于target的数， 也可以用这种方法</p><pre><code class="lang-c++">  // 模板一  vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {      int n = numbers.size();      for (int i = 0, j = n - 1; i &lt; r; i++) {  // 枚举每一个较小的数字          while (j &gt;= i &amp;&amp; numbers[i] + numbers[j] &gt; target) j--;          if (numbers[i] + numbers[j] == target) return {i + 1, j + 1};      }      return {};  }  // 模板二  vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {      int n = numbers.size();      int l = 0, r = n - 1;      while (l &lt; r) {          int sum = numbers[l] + numbers[r];          if (sum == target) {              return {l + 1, r + 1};  // 下标从1开始          }          if (sum &gt; target) r--;          else l++;      }      return {};  }</code></pre></li></ul><h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></h4><p>去重比较麻烦</p><ul><li>枚举i相同的时候需要去重</li><li>双指针找到一个解的时候需要去重</li></ul><pre><code class="lang-c++">// 模板一class Solution {public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {        vector&lt;vector&lt;int&gt;&gt; ans;        if (nums.size() &lt; 3) return ans;        int n = nums.size();        sort(nums.begin(), nums.end());        for (int i = 0; i &lt; n - 2; i++) {            if (nums[i] &gt; 0) break;   // 剪枝            if (i - 1 &gt;= 0 &amp;&amp; nums[i] == nums[i-1]) continue;  // 去重            int target = -nums[i];            for (int l = i + 1, r = n - 1; l &lt; r; l++) {                while (r &gt; l &amp;&amp; nums[l] + nums[r] &gt; target) r--;                if (r == l) break;   // !!!                int sum = nums[l] + nums[r];                if (sum == target) {                    ans.push_back({nums[i], nums[l], nums[r]});                    while (l &lt; r &amp;&amp; nums[l] == nums[l+1]) l++;  // 去重                    while (l &lt; r &amp;&amp; nums[r] == nums[r-1]) r--;  // 去重                    r--;                }            }        }        return ans;    }};</code></pre><pre><code class="lang-c++">// 模板二class Solution {public:    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {        vector&lt;vector&lt;int&gt;&gt; ans;        if (nums.size() &lt; 3) return ans;        int n = nums.size();        sort(nums.begin(), nums.end());        for (int i = 0; i &lt; n - 2; i++) {            if (nums[i] &gt; 0) break;  // 后面不用再找了            if (i - 1 &gt;= 0 &amp;&amp; nums[i] == nums[i-1]) continue; // 去重            // 双指针算法            int target = -nums[i];  // 再后面有序的序列找target            int l = i + 1, r = n - 1;            while (l &lt; r) {                int sum = nums[l] + nums[r];                if (sum &gt; target) {                    r--;                } else if (sum &lt; target) {                    l++;                } else {                    ans.push_back({nums[i], nums[l], nums[r]});                    while (l &lt; r &amp;&amp; nums[l] == nums[l+1]) l++; // 去重                    while (l &lt; r &amp;&amp; nums[r] == nums[r-1]) r--; // 去重                    l++;                    r--;                }            }        }        return ans;    }};</code></pre><h2 id="Hash表-滑动窗口"><a href="#Hash表-滑动窗口" class="headerlink" title="Hash表 + 滑动窗口"></a>Hash表 + 滑动窗口</h2><h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></h4><ul><li><p>通过维护一个滑动串口，找到最小覆盖的子串。</p></li><li><p>判断所有t字符中的数字是否在hash中，技巧：</p><ul><li><p>把t的所有字符统计个数，用一个变量rest表示还剩多少字符没有匹配，若<code>rest == 0</code>说明所有字符已经匹配完成（即0个字符没有匹配）. <strong>counts[c]为正的时候说明还需要多少c， counts[c]为负的时候说明多出来了多少c。</strong></p></li><li><p>每次添加则使用<code>if (counts.count(s[i]) &amp;&amp; --counts[s[i]] == 0) rest--;</code> ， 删除则使用 <code>if (counts.count(s[j]) &amp;&amp; counts[s[j]]++ == 0) rest++;</code> 。</p><p>PS: rest可以理解为开关，分界线是<code>counts[c] == 0</code>的时候，刚超过0，就还需要c字符。 刚减小到0的时候，c字符就够了。</p></li></ul></li></ul><pre><code class="lang-c++">// 固定尾class Solution {public:    string minWindow(string s, string t) {        if (t.empty() || s.empty() || t.length() &gt; s.length()) return &quot;&quot;;        int n = s.length(), rest = 0, j = 0, start = -1, len = n + 1;        unordered_map&lt;char, int&gt; counts;        for (char c : t) counts[c]++;        rest = counts.size();        for (int i = 0; i &lt; n; i++) {            if (counts.count(s[i]) &amp;&amp; --counts[s[i]] == 0) rest--;            while (rest == 0) {                if (i - j + 1 &lt;= len) start = j, len = i - j + 1;  // 推荐                if (counts.count(s[j]) &amp;&amp; counts[s[j]]++ == 0) rest++;                j++;            }        }        if (start == -1) return &quot;&quot;;        return s.substr(start, len);    }};</code></pre><pre><code class="lang-c++">// 固定头class Solution {public:    string minWindow(string s, string t) {        if (t.empty() || s.empty() || t.length() &gt; s.length()) return &quot;&quot;;        int n = s.length(), rest = 0, j = 0, start = -1, len = n + 1;        unordered_map&lt;char, int&gt; counts;        for (char c : t) counts[c]++;        rest = counts.size();        for (int i = 0; i &lt; n; i++) {            while (j &lt; n &amp;&amp; rest &gt; 0) {                if (counts.count(s[j]) &amp;&amp; --counts[s[j]] == 0) rest--;                j++;            }            if (rest == 0 &amp;&amp; len &gt; j - i) start = i, len = j - i;            if (counts.count(s[i]) &amp;&amp; counts[s[i]]++ == 0) rest++;        }        if (start == -1) return &quot;&quot;;        return s.substr(start, len);    }};</code></pre><h4 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. 找到字符串中所有字母异位词</a></h4><ul><li>通过滑动窗口找能够包含字符p，并且长度等于p的子串。</li></ul><pre><code class="lang-c++">// 固定尾class Solution {public:    vector&lt;int&gt; findAnagrams(string s, string p) {        if (p.empty() || s.empty() || s.length() &lt; p.length()) return {};        int n = s.length(), m = p.length(), j = 0, rest = 0;        vector&lt;int&gt; ans;        unordered_map&lt;char, int&gt; counts;        for (char c : p) counts[c]++;        rest = counts.size();        for (int i = 0; i &lt; n; i++) {            if (counts.count(s[i]) &amp;&amp; --counts[s[i]] == 0) rest--;            while (rest == 0) {                if (i - j + 1 == m) ans.push_back(j);  // 推荐                if (counts.count(s[j]) &amp;&amp; counts[s[j]]++ == 0) rest++;                j++;            }        }        return ans;    }};</code></pre><pre><code class="lang-c++">// 固定头class Solution {public:    vector&lt;int&gt; findAnagrams(string s, string p) {        if (p.empty() || s.empty() || s.length() &lt; p.length()) return {};        int n = s.length(), m = p.length(), j = 0, rest = 0;        vector&lt;int&gt; ans;        unordered_map&lt;char, int&gt; counts;        for (char c : p) counts[c]++;        rest = counts.size();        for (int i = 0; i &lt; n; i++) {            while (j &lt; n &amp;&amp; rest &gt; 0) {                if (counts.count(s[j]) &amp;&amp; --counts[s[j]] == 0) rest--;                j++;            }            if (rest == 0 &amp;&amp; j - i == m) ans.push_back(i);            if (counts.count(s[i]) &amp;&amp; counts[s[i]]++ == 0) rest++;        }        return ans;    }};</code></pre><h4 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></h4><ul><li>求最长的子串</li><li>枚举每个子串结尾， 看左端点最远可以到哪里。左端点具有单调性</li></ul><pre><code class="lang-c++">// 固定尾int lengthOfLongestSubstring(string s) {    if (s.empty()) return 0;    int n = s.length();    unordered_map&lt;char, int&gt; counts;    int j = 0, ans = 0;    for (int i = 0, j = 0; i &lt; n; i++) {        char cur = s[i];        counts[cur]++;        while (counts[cur] &gt; 1) {            counts[s[j]]--;            j++;        }        ans = max(ans, i - j + 1);    }    return ans;}</code></pre><pre><code class="lang-c++">// 固定头, 推荐，因为判断在while循环中int lengthOfLongestSubstring(string s) {    if (s.empty()) return 0;    int n = s.length();    unordered_map&lt;char, int&gt; counts;    int j = 0, ans = 0;    for (int i = 0; i &lt; n; i++) {        while (j &lt; n &amp;&amp; counts[s[j]] == 0) {            ans = max(ans, j - i + 1);   // 推荐            ++counts[s[j]];            ++j;        }        --counts[s[i]];    return ans;}</code></pre><h2 id="和至少为k的最短数组"><a href="#和至少为k的最短数组" class="headerlink" title="和至少为k的最短数组"></a>和至少为k的最短数组</h2><h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">209. 长度最小的子数组</a></h4><p>the ans is initialized as <code>ans = n + 1</code></p><p>One pass, remove the value from sum <code>s</code> by doing <code>s += nums[j]</code></p><p>if <code>s &lt;= 0</code>. It means the total sum of <code>nums[j] + ... + nums[i]</code>that we want.</p><p>Then we update the <code>ans = min(ans, i - j + 1)</code></p><p>Finally we return the answer <code>ans</code></p><pre><code class="lang-c++">// 固定尾指针写法class Solution {public:    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) {        int j = 0, n = nums.size(), ans = n + 1;        for (int i = 0; i &lt; nums.size(); i++) {            s -= nums[i];            while (s &lt;= 0) {                ans = min(ans, i - j + 1);  // 推荐                s += nums[j++];            }        }        return ans % (n + 1);    }};</code></pre><pre><code class="lang-c++">// 固定头指针写法class Solution {public:    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) {        int j = 0, n = nums.size(), ans = n + 1;        for (int i = 0; i &lt; nums.size(); i++) {            while (j &lt; n &amp;&amp; s &gt; 0) {                s -= nums[j++];            }            if (s &lt;= 0) ans = min(ans, j - i);            s += nums[i];        }        return ans % (n + 1);    }};</code></pre><h4 id="862-和至少为-K-的最短子数组"><a href="#862-和至少为-K-的最短子数组" class="headerlink" title="862. 和至少为 K 的最短子数组"></a><a href="https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k/" target="_blank" rel="noopener">862. 和至少为 K 的最短子数组</a></h4><h2 id="包含k个字符的最长子串"><a href="#包含k个字符的最长子串" class="headerlink" title="包含k个字符的最长子串"></a>包含k个字符的最长子串</h2><h4 id="340-至多包含-K-个不同字符的最长子串"><a href="#340-至多包含-K-个不同字符的最长子串" class="headerlink" title="340. 至多包含 K 个不同字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-k-distinct-characters/" target="_blank" rel="noopener">340. 至多包含 K 个不同字符的最长子串</a></h4><pre><code class="lang-c++">给定一个字符串 s ，找出 至多 包含 k 个不同字符的最长子串 T。输入: s = &quot;eceba&quot;, k = 2输出: 3解释: 则 T 为 &quot;ece&quot;，所以长度为 3。输入: s = &quot;aa&quot;, k = 1输出: 2解释: 则 T 为 &quot;aa&quot;，所以长度为 2。</code></pre><pre><code class="lang-c++">// 固定尾class Solution {public:    int lengthOfLongestSubstringKDistinct(string s, int k) {        if (s.empty()) return 0;        int n = s.length(), ans = 0, j = 0;        unordered_map&lt;char, int&gt; counts;        for (int i = 0; i &lt; n; i++) {            counts[s[i]]++;            while (counts.size() &gt; k) {                if (--counts[s[j]] == 0) counts.erase(s[j]);                j++;            }            ans = max(ans, i - j + 1);        }        return ans;    }};</code></pre><pre><code class="lang-c++">// 固定头class Solution {public:    int lengthOfLongestSubstringKDistinct(string s, int k) {        if (s.empty()) return 0;        int n = s.length(), ans = 0, j = 0;        unordered_map&lt;char, int&gt; counts;        for (int i = 0; i &lt; n; i++) {            while (j &lt; n &amp;&amp; counts.size() &lt;= k) {                // PS: [3,3,3,1,2,1,1,2,3,3,4] 易错                if (!counts.count(s[j]) &amp;&amp; counts.size() == k) break;                ans = max(ans, j - i + 1);                ++counts[s[j]];                j++;            }            if (--counts[s[i]] == 0) counts.erase(s[i]);        }        return ans;    }};</code></pre><h4 id="992-K-个不同整数的子数组"><a href="#992-K-个不同整数的子数组" class="headerlink" title="992. K 个不同整数的子数组"></a><a href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/" target="_blank" rel="noopener">992. K 个不同整数的子数组</a></h4><ul><li>转成atMost做</li></ul><pre><code class="lang-c++">class Solution {public:    int subarraysWithKDistinct(vector&lt;int&gt;&amp; A, int K) {        return atMost(A, K) - atMost(A, K-1);    }    int atMost(vector&lt;int&gt;&amp; A, int K) {        int n = A.size(), ans = 0, j = 0;        if (!n || K &lt;= 0 || K &gt; n) return 0;        unordered_map&lt;int, int&gt; counts;        for (int i = 0; i &lt; n; i++) {            while (j &lt; n &amp;&amp; counts.size() &lt;= K) {                if (counts.size() == K &amp;&amp; !counts.count(A[j])) break;                ans++;                counts[A[j]]++;                j++;            }            if (counts.size() &lt;= K) ans += j - i - 1;            if (--counts[A[i]] == 0) counts.erase(A[i]);        }        return ans;    }};</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="1358-包含所有三种字符的子字符串数目"><a href="#1358-包含所有三种字符的子字符串数目" class="headerlink" title="1358. 包含所有三种字符的子字符串数目"></a><a href="https://leetcode-cn.com/problems/number-of-substrings-containing-all-three-characters/" target="_blank" rel="noopener">1358. 包含所有三种字符的子字符串数目</a></h4><pre><code class="lang-c++">// 固定尾class Solution {public:    int numberOfSubstrings(string s) {        int counts[3] = {0, 0, 0};        int j = 0, ans = 0, n = s.length();        for (int i = 0; i &lt; n; i++) {            counts[s[i]-&#39;a&#39;]++;            while (counts[0] &amp;&amp; counts[1] &amp;&amp; counts[2]) {                ans += n - i;                counts[s[j]-&#39;a&#39;]--;                j++;            }        }        return ans;    }};</code></pre><pre><code class="lang-c++">// 固定头class Solution {public:    int numberOfSubstrings(string s) {        int counts[3] = {0, 0, 0};        int j = 0, ans = 0, n = s.length();        for (int i = 0; i &lt; n; i++) {            while (j &lt; n &amp;&amp; (!counts[0] || !counts[1] || !counts[2])) {                counts[s[j]-&#39;a&#39;]++;                j++;            }            if (counts[0] &amp;&amp; counts[1] &amp;&amp; counts[2]) ans += n - j + 1;            counts[s[i]-&#39;a&#39;]--;        }        return ans;    }};</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速排序</title>
    <link href="/2019/02/01/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/02/01/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h4 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h4><p><code>均摊时间：O(nlogn) &amp; 空间：O(logn)</code></p><ul><li>在数组选一个数v(选中间的)，把数组左边变成<code>&lt;=v</code>，右边变成<code>&gt;=v</code>,使用分治的思想，分别对<strong>左边</strong>和<strong>右边</strong>进行快速排序</li><li>理论上最优的策略是以他的中位数来做为划分依据, 让其划分得均匀</li></ul><p><em>注意：partition返回的是j，而不是i。</em></p><p><strong>解释：</strong><br><code>partition</code> 返回j的原因：<br><code>partition</code>假如以中点向下取整(l + r &gt;&gt; 1), 只剩下两个数的时候(如 <code>1 2</code>) 就会以左边的<code>1</code>为基准值<code>x</code>，<code>i</code> 和 <code>j</code> 最后会cross over，因为是do while循环， <strong>i会到2的位置， j会到1的位置</strong>。 这样左边(l, j)是小于等于1， 右边(i, r)是大于等于1.这样不会死循环。<strong>若返回i就会发生划分的左边死循环，一直是(1, 2)划分，无限递归下去</strong>。</p><p>若要<code>返回i</code>， 跟二分很像，则需要以中点向上取整(<code>l + r + 1 &gt;&gt; 1</code>)。 同理，还是以数组剩下两个元素（1， 2）为例， 基准值x取2. 当i, j cross over之后， 左边小于等于2为(<code>l, i - 1</code>), 右边大于等于2为(<code>i， r</code>)。</p><p><strong>为什么写do while 循环, 尝试例子数组排序 <code>1 2 1</code> , 死循环. 因为交换完的时候就卡住了.</strong></p><ul><li>向下取整</li></ul><pre><code class="lang-c++">int partition(int a[], int l, int r) {    int x = a[l + r &gt;&gt; 1];   //  下取整    int i = l - 1, j = r + 1;    while (i &lt; j) {        do ++i; while (a[i] &lt; x);        do --j; while (a[j] &gt; x);        if (i &lt; j) swap(a[i], a[j]);    }    return j;    // 一定是j}void quick_sort(int a[], int l, int r) {    if (l &gt;= r) return;    int p = partition(a, l, r);    quick_sort(a, l, p);   // 划分区间    quick_sort(a, p + 1, r);}</code></pre><ul><li>向上取整</li></ul><pre><code class="lang-c++">int partition(int a[], int l, int r) {    int x = a[l + r + 1 &gt;&gt; 1];   // 上取整    int i = l - 1, j = r + 1;    while (i &lt; j) {        do ++i; while (a[i] &lt; x);        do --j; while (a[j] &gt; x);        if (i &lt; j) swap(a[i], a[j]);    }    return i;   // 一定是i}void quick_sort(int a[], int l, int r) {    if (l &gt;= r) return;    int p = partition(l, r);    quick_sort(l, p - 1);   // 划分区间    quick_sort(p, r);}</code></pre><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="第k小的数"><a href="#第k小的数" class="headerlink" title="第k小的数"></a>第k小的数</h3><p>在无序数组中找第k小的数字</p><pre><code class="lang-c++">int partition(int a[], int l, int r) {    int x = a[l + r &gt;&gt; 1];    int i = l - 1, j = r + 1;    while (i &lt; j) {        do i++; while (a[i] &lt; x);        do j--; while (a[j] &gt; x);        if (i &lt; j) swap(a[i], a[j]);    }    return j;}int quick_sort(int a[], int l, int r, int k) {    if (l == r) return a[l];    int p = partition(a, l, r);    int leftNum = p - l + 1;  // 左边比基准值小的个数    if (leftNum &gt;= k) return quick_sort(a, l, p, k);   // 从左边找第k个的数    return quick_sort(a, p + 1, r, k - leftNum);   // 从右边找第k - leftNum的数, 因为左边已经有leftNum个数了}</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>归并排序</title>
    <link href="/2019/02/01/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <url>/2019/02/01/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h4 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h4><p><code>均摊时间：O(nlogn) &amp; 空间：O(n)</code></p><pre><code class="lang-c++">// const int N = 100010;// int t[N];void merge(int a[], int l, int mid, int r) {    int cnt = 0;  // 新数组t的长度    int i = l, j = mid + 1;    while (i &lt;= mid &amp;&amp; j &lt;= r) {        t[cnt++] = a[i] &lt;= a[j] ? a[i++] : a[j++];    }    while (i &lt;= mid) t[cnt++] = a[i++];    while (j &lt;= r) t[cnt++] = a[j++];    for (int i = 0; i &lt; cnt; i++) a[l+i] = t[i];}void merge_sort(int a[], int l, int r) {    if (l &gt;= r) return;    int mid = l + r &gt;&gt; 1;    merge_sort(a, l, mid);   // 排序左半边    merge_sort(a, mid + 1, r);    // 排序右半边    merge(a, l, mid, r);   // 合并左半边和右半边}</code></pre><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="求逆序数"><a href="#求逆序数" class="headerlink" title="求逆序数"></a>求逆序数</h3><pre><code class="lang-c++"></code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合类总结</title>
    <link href="/2018/12/19/Java%E9%9B%86%E5%90%88%E7%B1%BB%E6%80%BB%E7%BB%93/"/>
    <url>/2018/12/19/Java%E9%9B%86%E5%90%88%E7%B1%BB%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-刷题集合类"><a href="#Java-刷题集合类" class="headerlink" title="Java 刷题集合类"></a>Java 刷题集合类</h1><h2 id="快速查看"><a href="#快速查看" class="headerlink" title="快速查看"></a>快速查看</h2><div class="table-container"><table><thead><tr><th style="text-align:center">类</th><th style="text-align:center">方法</th></tr></thead><tbody><tr><td style="text-align:center">String</td><td style="text-align:center">charAt toCharArray split substring indexOf lastIndexOf replace length</td></tr><tr><td style="text-align:center">List</td><td style="text-align:center">add remove get size subList</td></tr><tr><td style="text-align:center">Stack</td><td style="text-align:center">push pop peek isEmpty size</td></tr><tr><td style="text-align:center">Queue</td><td style="text-align:center">offer poll peek isEmpty size</td></tr><tr><td style="text-align:center">PriorityQueue</td><td style="text-align:center">offer poll peek isEmpty size</td></tr><tr><td style="text-align:center">Set</td><td style="text-align:center">add remove contains isEmpty size first(TreeSet) last(TreeSet)</td></tr><tr><td style="text-align:center">Map</td><td style="text-align:center">put get getOrDefault containsKey containsValue keySet values isEmpty size</td></tr></tbody></table></div><h2 id="静态数组-Static-Array"><a href="#静态数组-Static-Array" class="headerlink" title="静态数组 Static Array"></a>静态数组 Static Array</h2><p>性质：初始化后长度不能变了</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h4><pre><code class="lang-java">// Type[] names = new Type[capacity];int[] a = new int[10];String[] s = new String[3];// Type[] names = new Type[]{Tpye ...a};int[] a = new int[]{1, 2, 3, 4};    // int[] a = {1, 2, 3, 4};char[] b = new char[]{&#39;a&#39;, &#39;b&#39;};    // char[] b = {&#39;a&#39;, &#39;b&#39;};String[] s = new String[]{&quot;hello&quot;, &quot;world&quot;};// 创建Set&lt;String&gt; set = new Set[105]; // 每一个指向一个nullfor (int i = 0; i &lt; 105; i++) jud[i] = new HashSet&lt;&gt;();  // 每个Set现在才被创建出来</code></pre><h4 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h4><pre><code class="lang-java">// 二维int[][] c = new int[10][10];</code></pre><h3 id="instance属性"><a href="#instance属性" class="headerlink" title="instance属性"></a>instance属性</h3><h4 id="length"><a href="#length" class="headerlink" title="length"></a>length</h4><p><code>.length</code> <em>记得是属性而不是方法 <code>arr.length</code> 没有()</em></p><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><h4 id="Arrays-sort从小到大排序"><a href="#Arrays-sort从小到大排序" class="headerlink" title="Arrays.sort从小到大排序"></a>Arrays.sort从小到大排序</h4><p><code>Arrays.sort(int[] arr)</code> <code>Arrays.sort(int[] arr, int fromIndex, int toIndex)</code> 数组类型只要实现了Comparable接口就行(基本数据类型int也可以)</p><pre><code class="lang-java">Arrays.sort(int[] arr, int fromIndex, int toIndex, 比较器); //一定是需要泛型Arrays.sort(arr, (o1, o2) -&gt; o2 - o1); //数组全部 从大到小排序 跟Collections.sort()一样Arrays.sort(arr, 0, 3, (o1, o2) -&gt; o2 - o1); //从大到小排序，只排序[0, 3)</code></pre><h4 id="Arrays-fill填满一个数组"><a href="#Arrays-fill填满一个数组" class="headerlink" title="Arrays.fill填满一个数组"></a>Arrays.fill填满一个数组</h4><pre><code class="lang-java">int[] a = new int[5];Arrays.fill(a, 1);</code></pre><h4 id="Arrays-copyOf-arr-clone-复制一个数组-二维数组也可以"><a href="#Arrays-copyOf-arr-clone-复制一个数组-二维数组也可以" class="headerlink" title="Arrays.copyOf / arr.clone()复制一个数组(二维数组也可以)"></a>Arrays.copyOf / arr.clone()复制一个数组(二维数组也可以)</h4><pre><code class="lang-java">int[] a = new int[5];int[] newA = Array.copyOf(a, 5);// orint[][] a = {{1}, {1,2}, {1,2,3}, {1,2,3,4}, {1,2,3,4,5}}; // 不是5*5，第一维1 2 3 4 5int[][] newa = a.clone(); // 不是5*5矩阵</code></pre><h2 id="动态数组-List-amp-Dynamic-Array"><a href="#动态数组-List-amp-Dynamic-Array" class="headerlink" title="动态数组 List &amp; Dynamic Array"></a>动态数组 List &amp; Dynamic Array</h2><p>性质: 可以动态扩容的数组</p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><h4 id="常规-ArrayList更常用"><a href="#常规-ArrayList更常用" class="headerlink" title="常规 - ArrayList更常用"></a>常规 - ArrayList更常用</h4><pre><code class="lang-java">List&lt;Integer&gt; array = new ArrayList&lt;&gt;();    // 数组List&lt;Integer&gt; list = new LinkedList&lt;&gt;();    // 链表</code></pre><h4 id="接受一个Stack、Set等容器为参数-以Set举例"><a href="#接受一个Stack、Set等容器为参数-以Set举例" class="headerlink" title="接受一个Stack、Set等容器为参数 - 以Set举例"></a>接受一个Stack、Set等容器为参数 - 以Set举例</h4><pre><code class="lang-java">// Set&lt;Integer&gt; a = new HashSet....List&lt;Integer&gt; b = new ArrayList&lt;&gt;(a);</code></pre><h3 id="instance方法（List接口方法）"><a href="#instance方法（List接口方法）" class="headerlink" title="instance方法（List接口方法）"></a>instance方法（List接口方法）</h3><p><em>方法：get, size, add, remove, subList</em></p><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><pre><code class="lang-java">.get(int index)    // 返回元素位置在index的元素e --- array O(1), list O(n)</code></pre><h4 id="size"><a href="#size" class="headerlink" title="size"></a>size</h4><pre><code class="lang-java">.size()    // 返回数组长度 --- O(1)</code></pre><h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><pre><code class="lang-java">.add(E e)    // 在尾部添加一个元素e --- O(1).add(int index, E e)    // 在index位置插一个元素e --- O(n)</code></pre><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><pre><code class="lang-java">.remove(int index)    // 删除位于index的元素，并返回删除元素e --- 删除最后元素为O(1)， 其余为O(n)//删除最后元素 list.remove(list.size() - 1);</code></pre><h4 id="subList"><a href="#subList" class="headerlink" title="subList"></a>subList</h4><pre><code class="lang-java">.subList(int from, int to)    // 相当于返回原数组的一个片段,但不要对其进行改动，改动会影响原数组 --- O(1)// List&lt;Integer&gt; list, 对原来的list和返回的list做的“非结构性修改”(non-structural changes)，//都会影响到彼此对方. 如果你在调用了sublist返回了子list之后，如果修改了原list的大小，那么之前产生的子list将会失效，变得不可使用</code></pre><h3 id="技巧-1"><a href="#技巧-1" class="headerlink" title="技巧"></a>技巧</h3><p><code>Collections.sort(list);</code> 从小到大排序<br><code>Collections.sort(list, (o1, o2) -&gt; o2 - o1);</code> 从大到小排序， 第二个参数为一个比较器<br>``</p><h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h2><p>性质： 先进后出</p><h3 id="初始化-唯一初始化方式"><a href="#初始化-唯一初始化方式" class="headerlink" title="初始化 (唯一初始化方式)"></a>初始化 (唯一初始化方式)</h3><pre><code class="lang-java">Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</code></pre><h3 id="instance方法"><a href="#instance方法" class="headerlink" title="instance方法"></a>instance方法</h3><p><em>方法：push, pop, peek, isEmpty, size</em></p><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><pre><code class="lang-java">.push(E e);    // 入栈元素e， 返回值为元素e --- O(1)</code></pre><h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><pre><code class="lang-java">.pop();    // 出栈一个元素，返回出栈元素e --- O(1)</code></pre><h4 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h4><pre><code class="lang-java">.peek();    // 查看栈顶元素， 返回值为栈顶元素e --- O(1)</code></pre><h4 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty"></a>isEmpty</h4><pre><code class="lang-java">.isEmpty()    // 若栈空返回true， 否则返回false --- O(1)</code></pre><h4 id="size-1"><a href="#size-1" class="headerlink" title="size"></a>size</h4><pre><code class="lang-java">.size()    // 返回栈中元素个数 --- O(1)</code></pre><h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h2><p>性质：先进先出<br>通过实现实现队列接口的LinkedList&lt;&gt;();</p><h3 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h3><h4 id="使用LinkedList实现Queue接口初始化"><a href="#使用LinkedList实现Queue接口初始化" class="headerlink" title="使用LinkedList实现Queue接口初始化"></a>使用LinkedList实现Queue接口初始化</h4><pre><code class="lang-java">Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();</code></pre><h4 id="把集合如Stack、Set、List等Collection作为参数"><a href="#把集合如Stack、Set、List等Collection作为参数" class="headerlink" title="把集合如Stack、Set、List等Collection作为参数"></a>把集合如Stack、Set、List等Collection作为参数</h4><pre><code class="lang-java">// Set&lt;Integer&gt; set = new HashSet&lt;&gt;();Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(set);</code></pre><h3 id="instance方法-Queue接口"><a href="#instance方法-Queue接口" class="headerlink" title="instance方法 (Queue接口)"></a>instance方法 (Queue接口)</h3><p><em>方法：offer, poll, peek, isEmpty, size</em></p><h4 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h4><pre><code class="lang-java">.offer(E e);    // 队尾加入元素e。 若成功入队返回值true，否则返回false --- O(1)</code></pre><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><pre><code class="lang-java">.poll();    // 出队首，返回出队元素e --- O(1)</code></pre><h4 id="peek-1"><a href="#peek-1" class="headerlink" title="peek"></a>peek</h4><pre><code class="lang-java">.peek();    // 查看队首元素， 返回值队首元素e --- O(1)</code></pre><h4 id="isEmpty-1"><a href="#isEmpty-1" class="headerlink" title="isEmpty"></a>isEmpty</h4><pre><code class="lang-java">.isEmpty()    // 若队空返回true， 否则返回false --- O(1)</code></pre><h4 id="size-2"><a href="#size-2" class="headerlink" title="size"></a>size</h4><pre><code class="lang-java">.size()    // 返回队中元素个数 --- O(1)</code></pre><h2 id="优先队列-PriorityQueue-Heap"><a href="#优先队列-PriorityQueue-Heap" class="headerlink" title="优先队列 PriorityQueue (Heap)"></a>优先队列 PriorityQueue (Heap)</h2><p>性质：底层是一颗数， 以小根堆为例。对于任意结点来说，该节点的值比其左右孩子的值都要小。 （就是最上面的结点最小）。 大根堆类似，最上面结点最大</p><h3 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h3><h4 id="小根堆"><a href="#小根堆" class="headerlink" title="小根堆"></a>小根堆</h4><pre><code class="lang-java">Queue&lt;Integer&gt; minH = new PriorityQueue&lt;&gt;();    // 小根堆，默认大小为11 相当于  new PriorityQueue&lt;&gt;(11)Queue&lt;Integer&gt; minH = new PriorityQueue&lt;&gt;(100);  // 定义一个默认容量有100的小根堆。在当中增加元素会扩容，只是开始指定大小。不是size，是capacity</code></pre><h4 id="大根堆"><a href="#大根堆" class="headerlink" title="大根堆"></a>大根堆</h4><pre><code class="lang-java">Queue&lt;Integer&gt; maxH = new PriorityQueue&lt;&gt;((i1, i2) -&gt; i2 - i1);    // 大根堆，默认大小为11 相当于  new PriorityQueue&lt;&gt;(11, (i1, i2) -&gt; i2 - i1)Queue&lt;Integer&gt; maxH = new PriorityQueue&lt;&gt;(100, (i1, i2) -&gt; i2 - i1);    // 定义一个默认容量有100的大根堆。在当中增加元素会扩容，只是开始指定大小</code></pre><h3 id="instance方法-Queue接口方法"><a href="#instance方法-Queue接口方法" class="headerlink" title="instance方法 (Queue接口方法)"></a>instance方法 (Queue接口方法)</h3><p><em>方法：offer, poll, peek, isEmpty, size</em></p><h4 id="offer-1"><a href="#offer-1" class="headerlink" title="offer"></a>offer</h4><pre><code class="lang-java">.offer(E e);    // 在堆中加入元素e，并调整堆。若成功入堆返回值true，否则返回false --- O(logN)</code></pre><h4 id="poll-1"><a href="#poll-1" class="headerlink" title="poll"></a>poll</h4><pre><code class="lang-java">.poll();    // 弹出堆顶元素，并重新调整堆，返回出队元素e --- O(logN)</code></pre><h4 id="peek-2"><a href="#peek-2" class="headerlink" title="peek"></a>peek</h4><pre><code class="lang-java">.peek();    // 查看堆顶元素， 返回值堆顶元素e --- O(1)</code></pre><h4 id="isEmpty-2"><a href="#isEmpty-2" class="headerlink" title="isEmpty"></a>isEmpty</h4><pre><code class="lang-java">.isEmpty()    // 若队空返回true， 否则返回false --- O(1)</code></pre><h4 id="size-3"><a href="#size-3" class="headerlink" title="size"></a>size</h4><pre><code class="lang-java">.size()    // 返回队中元素个数 --- O(1)</code></pre><h3 id="技巧-2"><a href="#技巧-2" class="headerlink" title="技巧"></a>技巧</h3><h4 id="从小到大（或从大到小弹出元素）"><a href="#从小到大（或从大到小弹出元素）" class="headerlink" title="从小到大（或从大到小弹出元素）"></a>从小到大（或从大到小弹出元素）</h4><pre><code class="lang-java">while (!pq.isEmpty()) {}</code></pre><h2 id="集合-Set-HashSet"><a href="#集合-Set-HashSet" class="headerlink" title="集合 Set - HashSet"></a>集合 Set - HashSet</h2><p>性质：Set中没有重复元素，重复添加的元素抛弃</p><h3 id="初始化-4"><a href="#初始化-4" class="headerlink" title="初始化"></a>初始化</h3><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><pre><code class="lang-java">Set&lt;Integer&gt; set = new HashSet&lt;&gt;();</code></pre><h4 id="把集合如Stack、Queue、List等Collection作为参数"><a href="#把集合如Stack、Queue、List等Collection作为参数" class="headerlink" title="把集合如Stack、Queue、List等Collection作为参数"></a>把集合如Stack、Queue、List等Collection作为参数</h4><pre><code class="lang-java">// List&lt;Integer&gt; list = new ArrayList&lt;&gt;....;// Set&lt;Integer&gt; set = new HashSet&lt;&gt;(list);</code></pre><h3 id="instance方法-Set接口方法"><a href="#instance方法-Set接口方法" class="headerlink" title="instance方法 (Set接口方法)"></a>instance方法 (Set接口方法)</h3><p><em>方法：add, remove, contains, isEmpty, size</em></p><h4 id="add-1"><a href="#add-1" class="headerlink" title="add"></a>add</h4><pre><code class="lang-java">.add(E e);    // 在集合中添加元素E e， 若成功添加则返回true，若集合中有元素e则返回false --- O(1)</code></pre><h4 id="remove-1"><a href="#remove-1" class="headerlink" title="remove"></a>remove</h4><pre><code class="lang-java">.remove(E e);    // 在集合中删除元素e，若删除成功返回true；若集合中没有元素e，返回false --- O(1)</code></pre><h4 id="contains"><a href="#contains" class="headerlink" title="contains"></a>contains</h4><pre><code class="lang-java">.contains(E e);    // 若存在元素e，则返回true，否则返回false --- O(1)</code></pre><h4 id="isEmpty-3"><a href="#isEmpty-3" class="headerlink" title="isEmpty"></a>isEmpty</h4><pre><code class="lang-java">.isEmpty()    // 若集合为空返回true， 否则返回false --- O(1)</code></pre><h4 id="size-4"><a href="#size-4" class="headerlink" title="size"></a>size</h4><pre><code class="lang-java">.size()    // 返回集合中中元素个数 --- O(1)</code></pre><h4 id="first-TreeSet"><a href="#first-TreeSet" class="headerlink" title="first (TreeSet)"></a>first (TreeSet)</h4><pre><code class="lang-java">.first()    // 返回集合里的最小值（若给了比较器从大到小则是返回最大值）</code></pre><h4 id="last-TreeSet"><a href="#last-TreeSet" class="headerlink" title="last (TreeSet)"></a>last (TreeSet)</h4><pre><code class="lang-java">.last()    // 返回集合里的最大值（若给了比较器从大到小则是返回最小值）</code></pre><h2 id="散列表-HashMap"><a href="#散列表-HashMap" class="headerlink" title="散列表 HashMap"></a>散列表 HashMap</h2><p>性质：使用健值对的方式存储数据 <Key,Value></p><h3 id="初始化-5"><a href="#初始化-5" class="headerlink" title="初始化"></a>初始化</h3><h4 id="key和value是任何Collection或任何Object"><a href="#key和value是任何Collection或任何Object" class="headerlink" title=" key和value是任何Collection或任何Object"></a><Key, Value> key和value是任何Collection或任何Object</h4><pre><code class="lang-java">Map&lt;Characters, Integer&gt; map = new HashMap&lt;&gt;();</code></pre><h3 id="instance方法-Map接口方法"><a href="#instance方法-Map接口方法" class="headerlink" title="instance方法 (Map接口方法)"></a>instance方法 (Map接口方法)</h3><p><em>方法：put, get, getOrDefault, containsKey, containsValue, keySet, values, isEmpty, size</em></p><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><pre><code class="lang-java">.put(K key, V value);    // 在Map中加入键值对&lt;key, value&gt;。返回value值。如果Map中有key，则replace旧的value --- O(1)</code></pre><h4 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h4><pre><code class="lang-java">.get(K key);    // 返回Map中key对应的value。若Map中没有该key，则返回null --- O(1)</code></pre><h4 id="getOrDefault"><a href="#getOrDefault" class="headerlink" title="getOrDefault"></a>getOrDefault</h4><pre><code class="lang-java">.getOrDefault(K key, V defaultValue);    // 返回Map中key对应的value。若Map中没有该key，则返回defaultValue --- O(1)// For example:// Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();// if (...)    // 如果发现k，则k在Map中的值加1。没一开始没有k，则从0开始加1。（相当于给了key在Map中的一个初试值）    map.put(&#39;k&#39;, map.getOrDefault(&#39;k&#39;, 0) + 1);</code></pre><h4 id="containsKey"><a href="#containsKey" class="headerlink" title="containsKey"></a>containsKey</h4><pre><code class="lang-java">.containsKey(Key key);    // 在Map中若存在key，则返回true，否则返回false --- O(1).get(x) == null // 可以代替改用法</code></pre><h4 id="containsValue"><a href="#containsValue" class="headerlink" title="containsValue"></a>containsValue</h4><pre><code class="lang-java">.containsValue(V value);    // 在Map中若存在value，则返回true，否则返回false --- O(1)</code></pre><h4 id="keySet"><a href="#keySet" class="headerlink" title="keySet"></a>keySet</h4><pre><code class="lang-java">.keySet();    // 返回一个Set,这个Set中包含Map中所有的Key --- O(1)// For example:// We want to get all keys in Map// Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();for (Character key : map.keySet()) {    // Operate with each key}</code></pre><h4 id="values"><a href="#values" class="headerlink" title="values"></a>values</h4><pre><code class="lang-java">.values();    // 返回一个Collection&lt;v&gt;,里面全是对应的每一个value --- O(1)// For example:// We want to get all values in Map// Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();for (Integer value : map.values()) {    // Operate with each values}</code></pre><h4 id="isEmpty-4"><a href="#isEmpty-4" class="headerlink" title="isEmpty"></a>isEmpty</h4><pre><code class="lang-java">.isEmpty()    // 若Map为空返回true， 否则返回false --- O(1)</code></pre><h4 id="size-5"><a href="#size-5" class="headerlink" title="size"></a>size</h4><pre><code class="lang-java">.size()    // 返回Map中中键值对&lt;K, V&gt;的个数 --- O(1)</code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>性质：不可变量(相当于只读final修饰)<br>每个位置元素是个char</p><h4 id="初始化-6"><a href="#初始化-6" class="headerlink" title="初始化"></a>初始化</h4><h5 id="字符串复制初始化"><a href="#字符串复制初始化" class="headerlink" title="字符串复制初始化"></a>字符串复制初始化</h5><pre><code class="lang-java">String s = &quot;abc&quot;;</code></pre><h5 id="基于另外一个字符串"><a href="#基于另外一个字符串" class="headerlink" title="基于另外一个字符串"></a>基于另外一个字符串</h5><pre><code class="lang-java">// s = &quot;abc&quot;String s2 = new String(s);</code></pre><h5 id="基于char"><a href="#基于char" class="headerlink" title="基于char[]"></a>基于char[]</h5><pre><code class="lang-java">// s = &quot;abc&quot;;// char[] c = s.toCharArray();String s3 = new String(c);// 可以偏移// public String(char value[], int offset, int count)String s4 = new String(c, 1, 2);    // [offset, offset + count) [)// 把char[] 变成字符串char[] ch = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;};String.valueOf(ch);</code></pre><h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><p><code>String.valueOf( 一个参数Object/基本数据类型 )</code> 返回传入参数obj的toString(),若为空返回字符串”null”。 若为基本类型调用其 包装类的toString方法（<code>Integer.toString(i)</code>）</p><h4 id="instance方法-1"><a href="#instance方法-1" class="headerlink" title="instance方法"></a>instance方法</h4><p><em>方法: charAt, length, substring, equals, indexOf, lastIndexOf, replace, toCharArray, trim, split, toLowerCase, toUpperCase</em></p><h5 id="charAt"><a href="#charAt" class="headerlink" title="charAt"></a>charAt</h5><pre><code class="lang-java">.charAt(int index);    // 返回index位置的char --- O(1)</code></pre><h5 id="length-1"><a href="#length-1" class="headerlink" title="length"></a>length</h5><pre><code class="lang-java">.length();    // 返回字符串长度 --- O(1)</code></pre><h5 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h5><pre><code class="lang-java">.substring(int beginIndex, int endIndex);    // 返回字符片段[beginIndex, endIndex) --- O(n).substring(int beginIndex);    // 返回字符片段[beginIndex, end_of_String) 就是从beginIndex开始后面的 ---- O(n)</code></pre><h5 id="indexOf-是（暴力查找字符串，不是KMP）"><a href="#indexOf-是（暴力查找字符串，不是KMP）" class="headerlink" title="indexOf 是（暴力查找字符串，不是KMP）"></a>indexOf 是（暴力查找字符串，不是KMP）</h5><pre><code class="lang-java">.indexOf(String str)    // 返回str第一个出现的位置(int)，没找到则返回-1。 --- O(m * n) m为原串长度， n为str长度// (假如要找一个字符char c，str可以表示成String.valueOf(c),然后作为参数传进去.s.indexOf(String str, int fromIndex);    // 同上，但从fromIndex开始找 --- O(m * n)</code></pre><h5 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h5><pre><code class="lang-java">.lastIndexOf(String str);    // 返回str最后出现的位置(int)，没找到则返回-1。 --- O(m * n) m为原串长度， n为str长度// (假如要找一个字符char c，str可以表示成String.valueOf(c),然后作为参数传进去..lastIndexOf(String str, int fromIndex);    // 同上，//但从fromIndex开始从后往前找 [0 &lt;- fromIndex] --- O(m * n)</code></pre><h5 id="replace-只能换char"><a href="#replace-只能换char" class="headerlink" title="replace 只能换char"></a>replace 只能换char</h5><pre><code class="lang-java">.replace(char oldChar, char newChar);    // 返回一个新字符串String，其oldChar全部变成newChar --- O(n)</code></pre><h5 id="toCharArray"><a href="#toCharArray" class="headerlink" title="toCharArray"></a>toCharArray</h5><pre><code class="lang-java">.toCharArray();    // 返回char[] 数组。 把String编程字符数组 --- O(n)</code></pre><h5 id="trim-去除前后空格"><a href="#trim-去除前后空格" class="headerlink" title="trim 去除前后空格"></a>trim 去除前后空格</h5><pre><code class="lang-java">.trim();    // 返回去除前后空格的新字符串 --- O(n)</code></pre><h5 id="split-以什么分开"><a href="#split-以什么分开" class="headerlink" title="split 以什么分开"></a>split 以什么分开</h5><pre><code class="lang-java">.split(String regex);    // 返回 String[]，以regex(正则表达式)分隔好的字符换数组。 ---- O(n)// For example// 从非&quot;/&quot;算起 若&quot;/a/c&quot; -&gt; 会变成&quot;&quot; &quot;a&quot; &quot;c&quot;String[] date = str.split(&quot;/&quot;);     // date[0]:1995 date[1]:12 date[2]:18 --- O(n)</code></pre><h5 id="toLowerCase-toUpperCase-转换大小写"><a href="#toLowerCase-toUpperCase-转换大小写" class="headerlink" title="toLowerCase, toUpperCase 转换大小写"></a>toLowerCase, toUpperCase 转换大小写</h5><pre><code class="lang-java">s = s.toLowerCase();    // 返回一个新的字符串全部转成小写 --- O(n)s = s.toUpperCase();    // 返回一个新的字符串全部转成大写 --- O(n)</code></pre><h4 id="技巧-3"><a href="#技巧-3" class="headerlink" title="技巧"></a>技巧</h4><p>通过<code>+</code>连接其他字符串， 但是是两个组成一个新的字符串，有开销。最好用StringBuilder</p><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><h4 id="初始化-7"><a href="#初始化-7" class="headerlink" title="初始化"></a>初始化</h4><pre><code class="lang-java">StringBuilder sb = new StringBuilder();</code></pre><h4 id="instance方法-2"><a href="#instance方法-2" class="headerlink" title="instance方法"></a>instance方法</h4><p><em>方法: append, charAt, length, setCharAt, insert, deleteCharAt, delete, reverse, toString</em></p><h5 id="charAt-1"><a href="#charAt-1" class="headerlink" title="charAt"></a>charAt</h5><pre><code class="lang-java">.charAt(int index);    // 返回index位置的char --- O(1)</code></pre><h5 id="length-2"><a href="#length-2" class="headerlink" title="length"></a>length</h5><pre><code class="lang-java">.length();    // 返回缓冲字符串长度 --- O(1)</code></pre><h5 id="setCharAt"><a href="#setCharAt" class="headerlink" title="setCharAt"></a>setCharAt</h5><pre><code class="lang-java">.setCharAt(int index, char ch);    // 设置index位置的char为ch --- O(1)</code></pre><h5 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h5><pre><code class="lang-java">.insert(int offset, String str);    // 在offer位置的插入字符串str--- O(m + n)</code></pre><h5 id="deleteCharAt"><a href="#deleteCharAt" class="headerlink" title="deleteCharAt"></a>deleteCharAt</h5><pre><code class="lang-java">.deleteCharAt(int index);    // 删除index位置的char --- O(n).deleteCharAt(sb.length() - 1);    // 删除最后一个char --- O(1)</code></pre><h5 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h5><pre><code class="lang-java">.delete(int start, int end);    // 删除[start, end)位置的char --- O(n)</code></pre><h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h5><pre><code class="lang-java">.reverse();    // 反转缓存字符串 --- O(n)</code></pre><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h5><pre><code class="lang-java">.toString();    // 返回一个与构建起或缓冲器内容相同的字符串 --- O(n)</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>技巧</category>
      
      <category>Java</category>
      
      <category>集合类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL Summary</title>
    <link href="/2018/12/18/STL_Summary/"/>
    <url>/2018/12/18/STL_Summary/</url>
    
    <content type="html"><![CDATA[<h1 id="STL-amp-C-刷题技巧"><a href="#STL-amp-C-刷题技巧" class="headerlink" title="STL &amp; C++刷题技巧"></a>STL &amp; C++刷题技巧</h1><a id="more"></a><div class="table-container"><table><thead><tr><th style="text-align:center">容器</th><th style="text-align:center">头文件</th><th style="text-align:center">方法</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center"><strong>vector</strong></td><td style="text-align:center">vector</td><td style="text-align:center"><code>push_back/pop_back</code> <code>resize</code> <code>erase</code> <code>front/back</code> <code>begin/ end</code> <code>size/clear/empty</code> <code>[]</code></td><td style="text-align:center">resize的参数跟初始化一样</td></tr><tr><td style="text-align:center"><strong>list</strong></td><td style="text-align:center">list</td><td style="text-align:center"><code>push_back/pop_back</code> <code>front/back</code> <code>erase</code> <code>begin/ end</code> <code>size/clear/empty</code> <code>[]</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>string</strong></td><td style="text-align:center">string</td><td style="text-align:center"><code>substr</code> <code>+=/push_back</code> <code>find</code> <code>c_str</code> <code>replace</code> <code>size/length/clear/empty</code> <code>[]</code></td><td style="text-align:center">getline(cin,s6); 读取字符到遇到换行，空格可读入，知道‘\n’结束. <code>c_str()</code>可以用printf %s输出 <code>to_string() / stoi()/stod()</code>在这个头文件中。  char转成字符串 <code>string(1, c)</code></td></tr><tr><td style="text-align:center"><strong>stack</strong></td><td style="text-align:center">stack</td><td style="text-align:center"><code>push</code> <code>pop</code> <code>top</code> <code>size/empty</code></td><td style="text-align:center"><strong>没有</strong><code>clear</code>， 要一个个弹出</td></tr><tr><td style="text-align:center"><strong>queue</strong></td><td style="text-align:center">queue</td><td style="text-align:center"><code>push</code> <code>pop</code> <code>top</code> <code>front/back</code> <code>size/empty</code></td><td style="text-align:center"><strong>没有</strong><code>clear</code>， 要一个个弹出</td></tr><tr><td style="text-align:center"><strong>priority_queue</strong></td><td style="text-align:center">queue</td><td style="text-align:center"><code>push/pop</code> <code>size/empty</code></td><td style="text-align:center">默认大根堆 小根堆<code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;</code> 小于的定义是反的</td></tr><tr><td style="text-align:center"><strong>deque</strong></td><td style="text-align:center">deque</td><td style="text-align:center"><code>push_back/pop_back</code> <code>front/back</code> <code>begin/ end</code> <code>size/clear/empty</code> <code>[]</code></td><td style="text-align:center">deque容器虽然支持随机访问，但是其<strong>随机访问</strong>速度慢于vector容器。插(删)头尾O(1)</td></tr><tr><td style="text-align:center"><strong>set</strong></td><td style="text-align:center">set</td><td style="text-align:center"><code>insert</code> <code>count / find</code> <code>erase</code> <code>begin/ end</code> <code>size/clear/empty</code></td><td style="text-align:center">自动去重升序排序 <code>O(logn)</code> <code>构造函数vector-&gt;set(v.begin(), v.end())</code></td></tr><tr><td style="text-align:center"><strong>unordered_set</strong></td><td style="text-align:center">unordered_set</td><td style="text-align:center"><code>insert</code> <code>count / find</code> <code>erase</code> <code>begin/ end</code> <code>size/clear/empty</code></td><td style="text-align:center"><code>O(1)</code></td></tr><tr><td style="text-align:center"><strong>map</strong></td><td style="text-align:center">map</td><td style="text-align:center"><code>insert</code> <code>count / find</code> <code>[]</code> <code>erase</code> <code>begin/ end</code> <code>size/clear/empty</code></td><td style="text-align:center">基于平衡树<code>O(logn)</code> 可以使用初始化列表</td></tr><tr><td style="text-align:center"><strong>unordered_map</strong></td><td style="text-align:center">unordered_map</td><td style="text-align:center"><code>insert</code> <code>count / find</code> <code>erase</code> <code>size/clear/empty</code></td><td style="text-align:center">基于哈希表<code>O(1)</code></td></tr><tr><td style="text-align:center"><strong>其他</strong></td><td style="text-align:center"></td><td style="text-align:center"><code>max_element</code> <code>lower_bound</code> <code>next_permutation</code></td><td style="text-align:center">！！！ 用<code>.size()</code>不要拿它做减法，返回的是<code>unsigned int</code>无符号整数做减法不会小于0</td></tr></tbody></table></div><h1 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h1><h2 id="保留几位小数"><a href="#保留几位小数" class="headerlink" title="保留几位小数"></a>保留几位小数</h2><pre><code class="lang-c++">printf(&quot;%.6f&quot;, k);  // 保留6位小数   (double - printf - %f) (doubel - scanf - %lf)</code></pre><h2 id="输入字符串包括空格"><a href="#输入字符串包括空格" class="headerlink" title="输入字符串包括空格"></a>输入字符串包括空格</h2><pre><code class="lang-c++">getline(cin,str);   // str 为 string</code></pre><h2 id="输入直到文字流结束-（ctrl-z）"><a href="#输入直到文字流结束-（ctrl-z）" class="headerlink" title="输入直到文字流结束 （ctrl + z）"></a>输入直到文字流结束 （ctrl + z）</h2><pre><code class="lang-c++">// scanfwhile (scanf(&quot;%d %d&quot;,&amp;a, &amp;b) != EOF) {    printf(&quot;%d\n&quot;, a + b);}// cinwhile (!cin.eof()) {    cin &gt;&gt; a &gt;&gt; b;    cout &lt;&lt; a + b &lt;&lt; endl;}</code></pre><h2 id="to-string-函数-把数字转成字符串的相互转换，负数也可以"><a href="#to-string-函数-把数字转成字符串的相互转换，负数也可以" class="headerlink" title="to_string() 函数 (把数字转成字符串的相互转换，负数也可以)"></a>to_string() 函数 (把数字转成字符串的相互转换，负数也可以)</h2><pre><code class="lang-c++">double f = 23.43string f_str = to_string(f);    // 23.430000double f_double = stod(f);   //转换回double  23.43</code></pre><p><strong>PS： char转成字符串 <code>string(1, c)</code>, 不能用to_string(c),这样是在转换成c的ASCII码</strong></p><h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><ul><li>pair对于排序来说是以first为第一关键字排序， second为第二关键字排序</li><li>赋值的时候可以使用花括号代替<code>{1, 2}</code></li></ul><h2 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h2><p>只能做这3个值<br>每4个字节赋值， Ox3f3f3f3f 大约是10^9次方多一点点</p><pre><code class="lang-c++">memset(h, -1, sizeof h);memset(h, 0, sizeof h);memset(h, 0x3f, sizeof h);  // memset这个函数是按字节来赋值的，int有4个字节，所以把每个字节都赋值成0x3f以后就是0x3f3f3f3f。</code></pre><h2 id="sort的比较函数的几种写法-（默认从小到大）"><a href="#sort的比较函数的几种写法-（默认从小到大）" class="headerlink" title="sort的比较函数的几种写法 （默认从小到大）"></a>sort的比较函数的几种写法 （默认从小到大）</h2><pre><code class="lang-c++">// 对vector排序sort(v.begin(), v.end(), [](const int&amp; a, const int&amp; b){return a &gt; b;});// 对数组排序sort(arr, arr + 100);</code></pre><h2 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h2><p>找到一个大于等于这个数的位置的迭代器</p><pre><code class="lang-c++">pos = lower_bound( number, number + 8, 3) - number  // number数组的下标为0的位置开始// 容器只可以返回迭代器， 然后使用distance函数判断跟begin()的距离int pos = distance(v.begin(), lower_bound(v.begin(), v.end(), 3));</code></pre><h2 id="一维-lt-—-gt-二维"><a href="#一维-lt-—-gt-二维" class="headerlink" title="一维 &lt;—&gt; 二维"></a>一维 &lt;—&gt; 二维</h2><pre><code>第k个元素 -&gt; n * m的矩阵a (都从0开始)// 一维转二维 k -&gt; [x][y] x = k / m; y = k % m; // 二维转一维 [x][y] -&gt; k k = x * m + y;</code></pre><h2 id="自定义结构体并重载小于号"><a href="#自定义结构体并重载小于号" class="headerlink" title="自定义结构体并重载小于号"></a>自定义结构体并重载小于号</h2><ul><li>结构体<code>=</code>为赋值操作，是整个结构体赋值过去。 而类只是浅拷贝</li><li>LeetCode中要写在类的外面</li><li>写在类中LeetCode需要在前面加friend。<a href="http://www.voidcn.com/article/p-okwlzxpt-zm.html" target="_blank" rel="noopener">参考</a></li><li>不要对pair进行重载运算符，最好自己定义结构体</li><li>遇到<code>priority_queue</code>的时候需要相反定义 (认为大的越小， 小的越大)</li></ul><pre><code class="lang-c++">struct Node {    int p1, p2;    Node(int p1, int p2) : p1(p1), p2(p2) {}};// 推荐方式 !!!!!!! bool operator&lt;(const Node&amp; a, const Node&amp; b){    if (a.p1 == b.p1) return a.p2 &lt; b.p2;    return a.p1 &lt; b.p1;}// 以p1为第一关键字， p2为第二关键字排序  &amp;&amp; 优先级比 || 高bool operator&lt;(const Node&amp; a, const Node&amp; b){    // return a.p1 &lt; b.p1 || !(b.p1 &lt; a.p1) &amp;&amp; a.p2 &lt; b.p2;    return a.p1 &lt; b.p1 || a.p1 == b.p1 &amp;&amp; a.p2 &lt; b.p2;}Node n1(1, 2);</code></pre><ul><li>为什么重载&lt;号要这样写，而不写成<code>return a.p1 &lt; b.p1 || a.p1 == b.p1 &amp;&amp; a.p2 &lt; b.p2</code>？因为p1和p2是int，他们虽然有重载<code>==</code>。但是对于没有重载<code>==</code>来说,只须重载小于运算符. <a href="https://blog.csdn.net/dpfordor/article/details/1958077" target="_blank" rel="noopener">参考文献</a></li></ul><h2 id="堆之标准比较器构造-对于指针来说可以使用"><a href="#堆之标准比较器构造-对于指针来说可以使用" class="headerlink" title="堆之标准比较器构造 (对于指针来说可以使用)"></a>堆之标准比较器构造 (对于指针来说可以使用)</h2><pre><code class="lang-c++">typedef pair&lt;string, int&gt; Node;typedef function&lt;bool(const Node&amp;, const Node&amp;)&gt; Compare;int main(){    // ...    Compare comparator = [](const Node&amp; a, const Node&amp; b) {        if (a.second == b.second)            return a.first &lt; b.first;    // order by alphabet  ASC        return a.second &gt; b.second;    // order by freq DESC    };    // Min heap by frequency    priority_queue&lt;Node, vector&lt;Node&gt;, Compare&gt; q(comparator);    // ...}</code></pre><p>关于指针的写法</p><pre><code class="lang-c++">    typedef function&lt;bool(const ListNode*, const ListNode*)&gt; Compare;    Compare cmp = [](const ListNode *a, const ListNode *b) {            return a-&gt;val &gt; b-&gt;val;    };    // 大根堆    priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, Compare&gt; q(cmp);</code></pre><h2 id="cin优化"><a href="#cin优化" class="headerlink" title="cin优化"></a>cin优化</h2><pre><code>// 两句话一起写ios::sync_with_stdio(false);cin.tie(0);</code></pre><h2 id="swap交换两个vector"><a href="#swap交换两个vector" class="headerlink" title="swap交换两个vector"></a>swap交换两个vector</h2><ul><li>O(1)时间，实质是指针交换</li></ul><pre><code class="lang-c++">swap(v1, v2);</code></pre><h2 id="max函数多参数"><a href="#max函数多参数" class="headerlink" title="max函数多参数"></a>max函数多参数</h2><ul><li>C++ 11之后支持传入参数初始化列表</li></ul><pre><code class="lang-c++">int mx = max({a, b, c, d});    // a, b, c, d的最大值</code></pre><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ul><li>数的最高位是符号位</li><li>左移去掉最高位，然后左边补0。 </li><li>右移根据正数还是负数决定。 正数最高位补0， 负数补1</li><li>（记）计算机以补码表示： 除符号位越大，数越大</li><li>2的n次方 <code>1 &lt;&lt; n</code> (n &lt;= 30)    (1后面几个0就是 2的几次方)</li><li><code>INT_MAX == 1后面31个零     INT_MAX == 0后面31个1</code></li><li>取反操作 <code>~</code></li></ul><h2 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h2><p><code>a &lt;= x &lt;= b</code></p><ul><li>方法一：两者差值不能超过INT_MAX</li></ul><pre><code class="lang-c++">srand(time(0));  // 先设置随机种子int randX(int a, int b) {   // a b数的差值不能超过INT_MAX    return a + (rand() % (b - a + 1));}// 生成方法int n = randX(1, 100);   // n ∈ [1, 100]</code></pre><ul><li>方法二：int间的任何数</li></ul><pre><code class="lang-c++">typedef long long ll;int myrand(int mod) { return ((ll)rand()&lt;&lt;32^(ll)rand()&lt;&lt;16^rand())%mod; }#define random(a, b)((a) + myrand((b) - (a) + 1)) // Integer[a,b]// 生成方法int n = random(INT_MIN, INT_MAX);  // n ∈ [-2147483648, 2147483647]</code></pre><h2 id="通过迭代器来初始化容器-hash表-lt-—-gt-vector"><a href="#通过迭代器来初始化容器-hash表-lt-—-gt-vector" class="headerlink" title="通过迭代器来初始化容器 hash表 &lt; — &gt; vector"></a>通过迭代器来初始化容器 hash表 &lt; — &gt; vector</h2><ul><li>set(map) &lt;-&gt; vector &lt;-&gt; string</li><li>总之有迭代器的都可以。 stack 和 queue没有</li></ul><pre><code class="lang-c++">vector&lt;int&gt; a = {3, 2, 1};set&lt;int&gt; se(a.begin(), a.end()); // vector -&gt; setvector&lt;int&gt; a2(se.begin(), se.end()); // set -&gt; vectorvector&lt;pair&lt;int, int&gt;&gt; a = {{3, 1}, {2, 1}, {1, 1}};unordered_map&lt;int, int&gt; mp(a.begin(), a.end()); //vector -&gt; mapvector&lt;pair&lt;int, int&gt;&gt; a2(mp.begin(), mp.end());  // map -&gt; vectorunordered_set&lt;char&gt; se(word.begin(), word.end()); //word 为 string</code></pre>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>算法</category>
      
      <category>STL</category>
      
      <category>技巧</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
